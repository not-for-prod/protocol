// Code generated by protoc-gen-goclay. DO NOT EDIT.
// source: api/api.proto

/*
Package api is a self-registering gRPC and JSON+Swagger service definition.

It conforms to the github.com/utrack/clay/v3/transport Service interface.
*/
package api

import (
	"bytes"
	"context"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	core "protocol/pb/core"
	contract "protocol/pb/core/contract"
	"strings"

	"github.com/go-chi/chi"
	"github.com/go-openapi/spec"
	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"github.com/grpc-ecosystem/grpc-gateway/v2/utilities"
	"github.com/pkg/errors"
	"github.com/utrack/clay/v3/transport"
	"github.com/utrack/clay/v3/transport/httpclient"
	"github.com/utrack/clay/v3/transport/httpruntime"
	"github.com/utrack/clay/v3/transport/httpruntime/httpmw"
	"github.com/utrack/clay/v3/transport/httptransport"
	"github.com/utrack/clay/v3/transport/swagger"
	"google.golang.org/grpc"
)

// Update your shared lib or downgrade generator to v1 if there's an error
var _ = transport.IsVersion2

var _ = ioutil.Discard
var _ chi.Router
var _ runtime.Marshaler
var _ bytes.Buffer
var _ context.Context
var _ fmt.Formatter
var _ strings.Reader
var _ errors.Frame
var _ httpruntime.Marshaler
var _ http.Handler
var _ url.Values
var _ base64.Encoding
var _ httptransport.MarshalerError
var _ utilities.DoubleArray

// WalletDesc is a descriptor/registrator for the WalletServer.
type WalletDesc struct {
	svc  WalletServer
	opts httptransport.DescOptions
}

// NewWalletServiceDesc creates new registrator for the WalletServer.
// It implements httptransport.ConfigurableServiceDesc as well.
func NewWalletServiceDesc(svc WalletServer) *WalletDesc {
	return &WalletDesc{
		svc: svc,
	}
}

// RegisterGRPC implements service registrator interface.
func (d *WalletDesc) RegisterGRPC(s *grpc.Server) {
	RegisterWalletServer(s, d.svc)
}

// Apply applies passed options.
func (d *WalletDesc) Apply(oo ...transport.DescOption) {
	for _, o := range oo {
		o.Apply(&d.opts)
	}
}

// SwaggerDef returns this file's Swagger definition.
func (d *WalletDesc) SwaggerDef(options ...swagger.Option) (result []byte) {
	if len(options) > 0 || len(d.opts.SwaggerDefaultOpts) > 0 {
		var err error
		var s = &spec.Swagger{}
		if err = s.UnmarshalJSON(_swaggerDef_api_api_proto); err != nil {
			panic("Bad swagger definition: " + err.Error())
		}

		for _, o := range d.opts.SwaggerDefaultOpts {
			o(s)
		}
		for _, o := range options {
			o(s)
		}
		if result, err = s.MarshalJSON(); err != nil {
			panic("Failed marshal spec.Swagger definition: " + err.Error())
		}
	} else {
		result = _swaggerDef_api_api_proto
	}
	return result
}

// RegisterHTTP registers this service's HTTP handlers/bindings.
func (d *WalletDesc) RegisterHTTP(mux transport.Router) {
	chiMux, isChi := mux.(chi.Router)

	{
		// Handler for GetAccount, binding: POST /wallet/getaccount
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetAccount_0(r)
			rsp, err := _Wallet_GetAccount_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetAccount_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetAccount_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetAccount, binding: GET /wallet/getaccount
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetAccount_1(r)
			rsp, err := _Wallet_GetAccount_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetAccount_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetAccount_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetAccountById, binding: POST /wallet/getaccountbyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetAccountById_0(r)
			rsp, err := _Wallet_GetAccountById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetAccountById_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetAccountById_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetAccountById, binding: GET /wallet/getaccountbyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetAccountById_1(r)
			rsp, err := _Wallet_GetAccountById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetAccountById_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetAccountById_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetAccountBalance, binding: POST /wallet/getaccountbalance
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetAccountBalance_0(r)
			rsp, err := _Wallet_GetAccountBalance_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetAccountBalance_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetAccountBalance_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetAccountBalance, binding: GET /wallet/getaccountbalance
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetAccountBalance_1(r)
			rsp, err := _Wallet_GetAccountBalance_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetAccountBalance_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetAccountBalance_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetBlockBalanceTrace, binding: POST /wallet/getblockbalancetrace
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetBlockBalanceTrace_0(r)
			rsp, err := _Wallet_GetBlockBalanceTrace_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetBlockBalanceTrace_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetBlockBalanceTrace_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetBlockBalanceTrace, binding: GET /wallet/getblockbalancetrace
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetBlockBalanceTrace_1(r)
			rsp, err := _Wallet_GetBlockBalanceTrace_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetBlockBalanceTrace_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetBlockBalanceTrace_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for CreateTransaction, binding: POST /wallet/createtransaction
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_CreateTransaction_0(r)
			rsp, err := _Wallet_CreateTransaction_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_CreateTransaction_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_CreateTransaction_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for CreateTransaction, binding: GET /wallet/createtransaction
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_CreateTransaction_1(r)
			rsp, err := _Wallet_CreateTransaction_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_CreateTransaction_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_CreateTransaction_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for BroadcastTransaction, binding: POST /wallet/broadcasttransaction
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_BroadcastTransaction_0(r)
			rsp, err := _Wallet_BroadcastTransaction_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_BroadcastTransaction_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_BroadcastTransaction_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for BroadcastTransaction, binding: GET /wallet/broadcasttransaction
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_BroadcastTransaction_1(r)
			rsp, err := _Wallet_BroadcastTransaction_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_BroadcastTransaction_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_BroadcastTransaction_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for UpdateAccount, binding: POST /wallet/updateaccount
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_UpdateAccount_0(r)
			rsp, err := _Wallet_UpdateAccount_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_UpdateAccount_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_UpdateAccount_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for UpdateAccount, binding: GET /wallet/updateaccount
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_UpdateAccount_1(r)
			rsp, err := _Wallet_UpdateAccount_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_UpdateAccount_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_UpdateAccount_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for SetAccountId, binding: POST /wallet/setaccountid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_SetAccountId_0(r)
			rsp, err := _Wallet_SetAccountId_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_SetAccountId_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_SetAccountId_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for SetAccountId, binding: GET /wallet/setaccountid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_SetAccountId_1(r)
			rsp, err := _Wallet_SetAccountId_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_SetAccountId_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_SetAccountId_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for VoteWitnessAccount, binding: POST /wallet/votewitnessaccount
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_VoteWitnessAccount_0(r)
			rsp, err := _Wallet_VoteWitnessAccount_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_VoteWitnessAccount_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_VoteWitnessAccount_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for VoteWitnessAccount, binding: GET /wallet/votewitnessaccount
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_VoteWitnessAccount_1(r)
			rsp, err := _Wallet_VoteWitnessAccount_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_VoteWitnessAccount_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_VoteWitnessAccount_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for CreateAssetIssue, binding: POST /wallet/createassetissue
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_CreateAssetIssue_0(r)
			rsp, err := _Wallet_CreateAssetIssue_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_CreateAssetIssue_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_CreateAssetIssue_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for CreateAssetIssue, binding: GET /wallet/createassetissue
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_CreateAssetIssue_1(r)
			rsp, err := _Wallet_CreateAssetIssue_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_CreateAssetIssue_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_CreateAssetIssue_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for UpdateWitness, binding: POST /wallet/updatewitness
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_UpdateWitness_0(r)
			rsp, err := _Wallet_UpdateWitness_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_UpdateWitness_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_UpdateWitness_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for UpdateWitness, binding: GET /wallet/updatewitness
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_UpdateWitness_1(r)
			rsp, err := _Wallet_UpdateWitness_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_UpdateWitness_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_UpdateWitness_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for CreateAccount, binding: POST /wallet/createaccount
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_CreateAccount_0(r)
			rsp, err := _Wallet_CreateAccount_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_CreateAccount_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_CreateAccount_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for CreateAccount, binding: GET /wallet/createaccount
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_CreateAccount_1(r)
			rsp, err := _Wallet_CreateAccount_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_CreateAccount_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_CreateAccount_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for CreateWitness, binding: POST /wallet/createwitness
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_CreateWitness_0(r)
			rsp, err := _Wallet_CreateWitness_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_CreateWitness_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_CreateWitness_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for CreateWitness, binding: GET /wallet/createwitness
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_CreateWitness_1(r)
			rsp, err := _Wallet_CreateWitness_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_CreateWitness_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_CreateWitness_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for TransferAsset, binding: POST /wallet/transferasset
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_TransferAsset_0(r)
			rsp, err := _Wallet_TransferAsset_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_TransferAsset_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_TransferAsset_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for TransferAsset, binding: GET /wallet/transferasset
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_TransferAsset_1(r)
			rsp, err := _Wallet_TransferAsset_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_TransferAsset_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_TransferAsset_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for ParticipateAssetIssue, binding: POST /wallet/participateassetissue
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_ParticipateAssetIssue_0(r)
			rsp, err := _Wallet_ParticipateAssetIssue_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_ParticipateAssetIssue_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_ParticipateAssetIssue_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for ParticipateAssetIssue, binding: GET /wallet/participateassetissue
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_ParticipateAssetIssue_1(r)
			rsp, err := _Wallet_ParticipateAssetIssue_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_ParticipateAssetIssue_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_ParticipateAssetIssue_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for FreezeBalance, binding: POST /wallet/freezebalance
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_FreezeBalance_0(r)
			rsp, err := _Wallet_FreezeBalance_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_FreezeBalance_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_FreezeBalance_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for FreezeBalance, binding: GET /wallet/freezebalance
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_FreezeBalance_1(r)
			rsp, err := _Wallet_FreezeBalance_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_FreezeBalance_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_FreezeBalance_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for UnfreezeBalance, binding: POST /wallet/unfreezebalance
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_UnfreezeBalance_0(r)
			rsp, err := _Wallet_UnfreezeBalance_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_UnfreezeBalance_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_UnfreezeBalance_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for UnfreezeBalance, binding: GET /wallet/unfreezebalance
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_UnfreezeBalance_1(r)
			rsp, err := _Wallet_UnfreezeBalance_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_UnfreezeBalance_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_UnfreezeBalance_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for UnfreezeAsset, binding: POST /wallet/unfreezeasset
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_UnfreezeAsset_0(r)
			rsp, err := _Wallet_UnfreezeAsset_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_UnfreezeAsset_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_UnfreezeAsset_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for UnfreezeAsset, binding: GET /wallet/unfreezeasset
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_UnfreezeAsset_1(r)
			rsp, err := _Wallet_UnfreezeAsset_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_UnfreezeAsset_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_UnfreezeAsset_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for WithdrawBalance, binding: POST /wallet/withdrawbalance
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_WithdrawBalance_0(r)
			rsp, err := _Wallet_WithdrawBalance_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_WithdrawBalance_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_WithdrawBalance_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for WithdrawBalance, binding: GET /wallet/withdrawbalance
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_WithdrawBalance_1(r)
			rsp, err := _Wallet_WithdrawBalance_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_WithdrawBalance_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_WithdrawBalance_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for UpdateAsset, binding: POST /wallet/updateasset
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_UpdateAsset_0(r)
			rsp, err := _Wallet_UpdateAsset_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_UpdateAsset_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_UpdateAsset_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for UpdateAsset, binding: GET /wallet/updateasset
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_UpdateAsset_1(r)
			rsp, err := _Wallet_UpdateAsset_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_UpdateAsset_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_UpdateAsset_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for ListNodes, binding: POST /wallet/listnodes
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_ListNodes_0(r)
			rsp, err := _Wallet_ListNodes_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_ListNodes_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_ListNodes_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for ListNodes, binding: GET /wallet/listnodes
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_ListNodes_1(r)
			rsp, err := _Wallet_ListNodes_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_ListNodes_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_ListNodes_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetAssetIssueByAccount, binding: POST /wallet/getassetissuebyaccount
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetAssetIssueByAccount_0(r)
			rsp, err := _Wallet_GetAssetIssueByAccount_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetAssetIssueByAccount_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetAssetIssueByAccount_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetAssetIssueByAccount, binding: GET /wallet/getassetissuebyaccount
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetAssetIssueByAccount_1(r)
			rsp, err := _Wallet_GetAssetIssueByAccount_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetAssetIssueByAccount_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetAssetIssueByAccount_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetAccountNet, binding: POST /wallet/getaccountnet
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetAccountNet_0(r)
			rsp, err := _Wallet_GetAccountNet_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetAccountNet_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetAccountNet_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetAccountNet, binding: GET /wallet/getaccountnet
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetAccountNet_1(r)
			rsp, err := _Wallet_GetAccountNet_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetAccountNet_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetAccountNet_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetAssetIssueByName, binding: POST /wallet/getassetissuebyname
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetAssetIssueByName_0(r)
			rsp, err := _Wallet_GetAssetIssueByName_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetAssetIssueByName_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetAssetIssueByName_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetAssetIssueByName, binding: GET /wallet/getassetissuebyname
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetAssetIssueByName_1(r)
			rsp, err := _Wallet_GetAssetIssueByName_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetAssetIssueByName_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetAssetIssueByName_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetNowBlock, binding: POST /wallet/getnowblock
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetNowBlock_0(r)
			rsp, err := _Wallet_GetNowBlock_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetNowBlock_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetNowBlock_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetNowBlock, binding: GET /wallet/getnowblock
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetNowBlock_1(r)
			rsp, err := _Wallet_GetNowBlock_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetNowBlock_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetNowBlock_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetBlockByNum, binding: POST /wallet/getblockbynum
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetBlockByNum_0(r)
			rsp, err := _Wallet_GetBlockByNum_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetBlockByNum_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetBlockByNum_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetBlockByNum, binding: GET /wallet/getblockbynum
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetBlockByNum_1(r)
			rsp, err := _Wallet_GetBlockByNum_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetBlockByNum_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetBlockByNum_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetBlockById, binding: POST /wallet/getblockbyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetBlockById_0(r)
			rsp, err := _Wallet_GetBlockById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetBlockById_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetBlockById_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetBlockById, binding: GET /wallet/getblockbyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetBlockById_1(r)
			rsp, err := _Wallet_GetBlockById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetBlockById_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetBlockById_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetBlockByLimitNext, binding: POST /wallet/getblockbylimitnext
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetBlockByLimitNext_0(r)
			rsp, err := _Wallet_GetBlockByLimitNext_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetBlockByLimitNext_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetBlockByLimitNext_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetBlockByLimitNext, binding: GET /wallet/getblockbylimitnext
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetBlockByLimitNext_1(r)
			rsp, err := _Wallet_GetBlockByLimitNext_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetBlockByLimitNext_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetBlockByLimitNext_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetBlockByLatestNum, binding: POST /wallet/getblockbylatestnum
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetBlockByLatestNum_0(r)
			rsp, err := _Wallet_GetBlockByLatestNum_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetBlockByLatestNum_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetBlockByLatestNum_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetBlockByLatestNum, binding: GET /wallet/getblockbylatestnum
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetBlockByLatestNum_1(r)
			rsp, err := _Wallet_GetBlockByLatestNum_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetBlockByLatestNum_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetBlockByLatestNum_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetTransactionById, binding: POST /wallet/gettransactionbyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetTransactionById_0(r)
			rsp, err := _Wallet_GetTransactionById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetTransactionById_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetTransactionById_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetTransactionById, binding: GET /wallet/gettransactionbyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetTransactionById_1(r)
			rsp, err := _Wallet_GetTransactionById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetTransactionById_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetTransactionById_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for ListWitnesses, binding: POST /wallet/listwitnesses
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_ListWitnesses_0(r)
			rsp, err := _Wallet_ListWitnesses_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_ListWitnesses_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_ListWitnesses_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for ListWitnesses, binding: GET /wallet/listwitnesses
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_ListWitnesses_1(r)
			rsp, err := _Wallet_ListWitnesses_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_ListWitnesses_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_ListWitnesses_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for ListProposals, binding: POST /wallet/listproposals
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_ListProposals_0(r)
			rsp, err := _Wallet_ListProposals_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_ListProposals_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_ListProposals_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for ListProposals, binding: GET /wallet/listproposals
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_ListProposals_1(r)
			rsp, err := _Wallet_ListProposals_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_ListProposals_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_ListProposals_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetPaginatedProposalList, binding: POST /wallet/getpaginatedproposallist
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetPaginatedProposalList_0(r)
			rsp, err := _Wallet_GetPaginatedProposalList_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetPaginatedProposalList_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetPaginatedProposalList_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetPaginatedProposalList, binding: GET /wallet/getpaginatedproposallist
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetPaginatedProposalList_1(r)
			rsp, err := _Wallet_GetPaginatedProposalList_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetPaginatedProposalList_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetPaginatedProposalList_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetProposalById, binding: POST /wallet/getproposalbyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetProposalById_0(r)
			rsp, err := _Wallet_GetProposalById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetProposalById_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetProposalById_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetProposalById, binding: GET /wallet/getproposalbyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetProposalById_1(r)
			rsp, err := _Wallet_GetProposalById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetProposalById_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetProposalById_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for ListExchanges, binding: POST /wallet/listexchanges
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_ListExchanges_0(r)
			rsp, err := _Wallet_ListExchanges_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_ListExchanges_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_ListExchanges_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for ListExchanges, binding: GET /wallet/listexchanges
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_ListExchanges_1(r)
			rsp, err := _Wallet_ListExchanges_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_ListExchanges_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_ListExchanges_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetPaginatedExchangeList, binding: POST /wallet/getpaginatedexchangelist
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetPaginatedExchangeList_0(r)
			rsp, err := _Wallet_GetPaginatedExchangeList_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetPaginatedExchangeList_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetPaginatedExchangeList_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetPaginatedExchangeList, binding: GET /wallet/getpaginatedexchangelist
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetPaginatedExchangeList_1(r)
			rsp, err := _Wallet_GetPaginatedExchangeList_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetPaginatedExchangeList_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetPaginatedExchangeList_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetExchangeById, binding: POST /wallet/getexchangebyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetExchangeById_0(r)
			rsp, err := _Wallet_GetExchangeById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetExchangeById_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetExchangeById_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetExchangeById, binding: GET /wallet/getexchangebyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetExchangeById_1(r)
			rsp, err := _Wallet_GetExchangeById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetExchangeById_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetExchangeById_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetChainParameters, binding: POST /wallet/getchainparameters
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetChainParameters_0(r)
			rsp, err := _Wallet_GetChainParameters_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetChainParameters_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetChainParameters_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetChainParameters, binding: GET /wallet/getchainparameters
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetChainParameters_1(r)
			rsp, err := _Wallet_GetChainParameters_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetChainParameters_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetChainParameters_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetAssetIssueList, binding: POST /wallet/getassetissuelist
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetAssetIssueList_0(r)
			rsp, err := _Wallet_GetAssetIssueList_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetAssetIssueList_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetAssetIssueList_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetAssetIssueList, binding: GET /wallet/getassetissuelist
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetAssetIssueList_1(r)
			rsp, err := _Wallet_GetAssetIssueList_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetAssetIssueList_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetAssetIssueList_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetPaginatedAssetIssueList, binding: POST /wallet/getpaginatedassetissuelist
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetPaginatedAssetIssueList_0(r)
			rsp, err := _Wallet_GetPaginatedAssetIssueList_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetPaginatedAssetIssueList_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetPaginatedAssetIssueList_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetPaginatedAssetIssueList, binding: GET /wallet/getpaginatedassetissuelist
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetPaginatedAssetIssueList_1(r)
			rsp, err := _Wallet_GetPaginatedAssetIssueList_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetPaginatedAssetIssueList_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetPaginatedAssetIssueList_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for TotalTransaction, binding: POST /wallet/totaltransaction
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_TotalTransaction_0(r)
			rsp, err := _Wallet_TotalTransaction_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_TotalTransaction_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_TotalTransaction_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for TotalTransaction, binding: GET /wallet/totaltransaction
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_TotalTransaction_1(r)
			rsp, err := _Wallet_TotalTransaction_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_TotalTransaction_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_TotalTransaction_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetNextMaintenanceTime, binding: POST /wallet/getnextmaintenancetime
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetNextMaintenanceTime_0(r)
			rsp, err := _Wallet_GetNextMaintenanceTime_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetNextMaintenanceTime_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetNextMaintenanceTime_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetNextMaintenanceTime, binding: GET /wallet/getnextmaintenancetime
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetNextMaintenanceTime_1(r)
			rsp, err := _Wallet_GetNextMaintenanceTime_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetNextMaintenanceTime_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetNextMaintenanceTime_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetTransactionInfoById, binding: POST /wallet/gettransactioninfobyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetTransactionInfoById_0(r)
			rsp, err := _Wallet_GetTransactionInfoById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_GetTransactionInfoById_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetTransactionInfoById_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetTransactionInfoById, binding: GET /wallet/gettransactioninfobyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_GetTransactionInfoById_1(r)
			rsp, err := _Wallet_GetTransactionInfoById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_GetTransactionInfoById_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_GetTransactionInfoById_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for AccountPermissionUpdate, binding: POST /wallet/accountpermissionupdate
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_AccountPermissionUpdate_0(r)
			rsp, err := _Wallet_AccountPermissionUpdate_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Wallet_AccountPermissionUpdate_0, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_AccountPermissionUpdate_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for AccountPermissionUpdate, binding: GET /wallet/accountpermissionupdate
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Wallet_AccountPermissionUpdate_1(r)
			rsp, err := _Wallet_AccountPermissionUpdate_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Wallet_AccountPermissionUpdate_1, h)
		} else {
			mux.Handle(pattern_goclay_Wallet_AccountPermissionUpdate_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

}

// WalletSolidityDesc is a descriptor/registrator for the WalletSolidityServer.
type WalletSolidityDesc struct {
	svc  WalletSolidityServer
	opts httptransport.DescOptions
}

// NewWalletSolidityServiceDesc creates new registrator for the WalletSolidityServer.
// It implements httptransport.ConfigurableServiceDesc as well.
func NewWalletSolidityServiceDesc(svc WalletSolidityServer) *WalletSolidityDesc {
	return &WalletSolidityDesc{
		svc: svc,
	}
}

// RegisterGRPC implements service registrator interface.
func (d *WalletSolidityDesc) RegisterGRPC(s *grpc.Server) {
	RegisterWalletSolidityServer(s, d.svc)
}

// Apply applies passed options.
func (d *WalletSolidityDesc) Apply(oo ...transport.DescOption) {
	for _, o := range oo {
		o.Apply(&d.opts)
	}
}

// SwaggerDef returns this file's Swagger definition.
func (d *WalletSolidityDesc) SwaggerDef(options ...swagger.Option) (result []byte) {
	if len(options) > 0 || len(d.opts.SwaggerDefaultOpts) > 0 {
		var err error
		var s = &spec.Swagger{}
		if err = s.UnmarshalJSON(_swaggerDef_api_api_proto); err != nil {
			panic("Bad swagger definition: " + err.Error())
		}

		for _, o := range d.opts.SwaggerDefaultOpts {
			o(s)
		}
		for _, o := range options {
			o(s)
		}
		if result, err = s.MarshalJSON(); err != nil {
			panic("Failed marshal spec.Swagger definition: " + err.Error())
		}
	} else {
		result = _swaggerDef_api_api_proto
	}
	return result
}

// RegisterHTTP registers this service's HTTP handlers/bindings.
func (d *WalletSolidityDesc) RegisterHTTP(mux transport.Router) {
	chiMux, isChi := mux.(chi.Router)

	{
		// Handler for GetAccount, binding: POST /walletsolidity/getaccount
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetAccount_0(r)
			rsp, err := _WalletSolidity_GetAccount_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_WalletSolidity_GetAccount_0, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetAccount_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetAccount, binding: GET /walletsolidity/getaccount
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetAccount_1(r)
			rsp, err := _WalletSolidity_GetAccount_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_WalletSolidity_GetAccount_1, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetAccount_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetAccountById, binding: POST /walletsolidity/getaccountbyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetAccountById_0(r)
			rsp, err := _WalletSolidity_GetAccountById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_WalletSolidity_GetAccountById_0, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetAccountById_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetAccountById, binding: GET /walletsolidity/getaccountbyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetAccountById_1(r)
			rsp, err := _WalletSolidity_GetAccountById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_WalletSolidity_GetAccountById_1, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetAccountById_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for ListWitnesses, binding: POST /walletsolidity/listwitnesses
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_ListWitnesses_0(r)
			rsp, err := _WalletSolidity_ListWitnesses_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_WalletSolidity_ListWitnesses_0, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_ListWitnesses_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for ListWitnesses, binding: GET /walletsolidity/listwitnesses
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_ListWitnesses_1(r)
			rsp, err := _WalletSolidity_ListWitnesses_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_WalletSolidity_ListWitnesses_1, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_ListWitnesses_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetAssetIssueList, binding: POST /walletsolidity/getassetissuelist
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetAssetIssueList_0(r)
			rsp, err := _WalletSolidity_GetAssetIssueList_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_WalletSolidity_GetAssetIssueList_0, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetAssetIssueList_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetAssetIssueList, binding: GET /walletsolidity/getassetissuelist
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetAssetIssueList_1(r)
			rsp, err := _WalletSolidity_GetAssetIssueList_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_WalletSolidity_GetAssetIssueList_1, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetAssetIssueList_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetPaginatedAssetIssueList, binding: POST /walletsolidity/getpaginatedassetissuelist
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetPaginatedAssetIssueList_0(r)
			rsp, err := _WalletSolidity_GetPaginatedAssetIssueList_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_WalletSolidity_GetPaginatedAssetIssueList_0, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetPaginatedAssetIssueList_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetPaginatedAssetIssueList, binding: GET /walletsolidity/getpaginatedassetissuelist
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetPaginatedAssetIssueList_1(r)
			rsp, err := _WalletSolidity_GetPaginatedAssetIssueList_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_WalletSolidity_GetPaginatedAssetIssueList_1, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetPaginatedAssetIssueList_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetNowBlock, binding: POST /walletsolidity/getnowblock
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetNowBlock_0(r)
			rsp, err := _WalletSolidity_GetNowBlock_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_WalletSolidity_GetNowBlock_0, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetNowBlock_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetNowBlock, binding: GET /walletsolidity/getnowblock
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetNowBlock_1(r)
			rsp, err := _WalletSolidity_GetNowBlock_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_WalletSolidity_GetNowBlock_1, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetNowBlock_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetBlockByNum, binding: POST /walletsolidity/getblockbynum
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetBlockByNum_0(r)
			rsp, err := _WalletSolidity_GetBlockByNum_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_WalletSolidity_GetBlockByNum_0, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetBlockByNum_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetBlockByNum, binding: GET /walletsolidity/getblockbynum
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetBlockByNum_1(r)
			rsp, err := _WalletSolidity_GetBlockByNum_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_WalletSolidity_GetBlockByNum_1, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetBlockByNum_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetTransactionById, binding: POST /walletsolidity/gettransactionbyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetTransactionById_0(r)
			rsp, err := _WalletSolidity_GetTransactionById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_WalletSolidity_GetTransactionById_0, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetTransactionById_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetTransactionById, binding: GET /walletsolidity/gettransactionbyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetTransactionById_1(r)
			rsp, err := _WalletSolidity_GetTransactionById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_WalletSolidity_GetTransactionById_1, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetTransactionById_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetTransactionInfoById, binding: POST /walletsolidity/gettransactioninfobyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetTransactionInfoById_0(r)
			rsp, err := _WalletSolidity_GetTransactionInfoById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_WalletSolidity_GetTransactionInfoById_0, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetTransactionInfoById_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetTransactionInfoById, binding: GET /walletsolidity/gettransactioninfobyid
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletSolidity_GetTransactionInfoById_1(r)
			rsp, err := _WalletSolidity_GetTransactionInfoById_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_WalletSolidity_GetTransactionInfoById_1, h)
		} else {
			mux.Handle(pattern_goclay_WalletSolidity_GetTransactionInfoById_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

}

// WalletExtensionDesc is a descriptor/registrator for the WalletExtensionServer.
type WalletExtensionDesc struct {
	svc  WalletExtensionServer
	opts httptransport.DescOptions
}

// NewWalletExtensionServiceDesc creates new registrator for the WalletExtensionServer.
// It implements httptransport.ConfigurableServiceDesc as well.
func NewWalletExtensionServiceDesc(svc WalletExtensionServer) *WalletExtensionDesc {
	return &WalletExtensionDesc{
		svc: svc,
	}
}

// RegisterGRPC implements service registrator interface.
func (d *WalletExtensionDesc) RegisterGRPC(s *grpc.Server) {
	RegisterWalletExtensionServer(s, d.svc)
}

// Apply applies passed options.
func (d *WalletExtensionDesc) Apply(oo ...transport.DescOption) {
	for _, o := range oo {
		o.Apply(&d.opts)
	}
}

// SwaggerDef returns this file's Swagger definition.
func (d *WalletExtensionDesc) SwaggerDef(options ...swagger.Option) (result []byte) {
	if len(options) > 0 || len(d.opts.SwaggerDefaultOpts) > 0 {
		var err error
		var s = &spec.Swagger{}
		if err = s.UnmarshalJSON(_swaggerDef_api_api_proto); err != nil {
			panic("Bad swagger definition: " + err.Error())
		}

		for _, o := range d.opts.SwaggerDefaultOpts {
			o(s)
		}
		for _, o := range options {
			o(s)
		}
		if result, err = s.MarshalJSON(); err != nil {
			panic("Failed marshal spec.Swagger definition: " + err.Error())
		}
	} else {
		result = _swaggerDef_api_api_proto
	}
	return result
}

// RegisterHTTP registers this service's HTTP handlers/bindings.
func (d *WalletExtensionDesc) RegisterHTTP(mux transport.Router) {
	chiMux, isChi := mux.(chi.Router)

	{
		// Handler for GetTransactionsFromThis, binding: POST /walletextension/gettransactionsfromthis
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletExtension_GetTransactionsFromThis_0(r)
			rsp, err := _WalletExtension_GetTransactionsFromThis_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_WalletExtension_GetTransactionsFromThis_0, h)
		} else {
			mux.Handle(pattern_goclay_WalletExtension_GetTransactionsFromThis_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetTransactionsFromThis, binding: GET /walletextension/gettransactionsfromthis
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletExtension_GetTransactionsFromThis_1(r)
			rsp, err := _WalletExtension_GetTransactionsFromThis_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_WalletExtension_GetTransactionsFromThis_1, h)
		} else {
			mux.Handle(pattern_goclay_WalletExtension_GetTransactionsFromThis_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetTransactionsToThis, binding: POST /walletextension/gettransactionstothis
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletExtension_GetTransactionsToThis_0(r)
			rsp, err := _WalletExtension_GetTransactionsToThis_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_WalletExtension_GetTransactionsToThis_0, h)
		} else {
			mux.Handle(pattern_goclay_WalletExtension_GetTransactionsToThis_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetTransactionsToThis, binding: GET /walletextension/gettransactionstothis
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_WalletExtension_GetTransactionsToThis_1(r)
			rsp, err := _WalletExtension_GetTransactionsToThis_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_WalletExtension_GetTransactionsToThis_1, h)
		} else {
			mux.Handle(pattern_goclay_WalletExtension_GetTransactionsToThis_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

}

// DatabaseDesc is a descriptor/registrator for the DatabaseServer.
type DatabaseDesc struct {
	svc  DatabaseServer
	opts httptransport.DescOptions
}

// NewDatabaseServiceDesc creates new registrator for the DatabaseServer.
// It implements httptransport.ConfigurableServiceDesc as well.
func NewDatabaseServiceDesc(svc DatabaseServer) *DatabaseDesc {
	return &DatabaseDesc{
		svc: svc,
	}
}

// RegisterGRPC implements service registrator interface.
func (d *DatabaseDesc) RegisterGRPC(s *grpc.Server) {
	RegisterDatabaseServer(s, d.svc)
}

// Apply applies passed options.
func (d *DatabaseDesc) Apply(oo ...transport.DescOption) {
	for _, o := range oo {
		o.Apply(&d.opts)
	}
}

// SwaggerDef returns this file's Swagger definition.
func (d *DatabaseDesc) SwaggerDef(options ...swagger.Option) (result []byte) {
	if len(options) > 0 || len(d.opts.SwaggerDefaultOpts) > 0 {
		var err error
		var s = &spec.Swagger{}
		if err = s.UnmarshalJSON(_swaggerDef_api_api_proto); err != nil {
			panic("Bad swagger definition: " + err.Error())
		}

		for _, o := range d.opts.SwaggerDefaultOpts {
			o(s)
		}
		for _, o := range options {
			o(s)
		}
		if result, err = s.MarshalJSON(); err != nil {
			panic("Failed marshal spec.Swagger definition: " + err.Error())
		}
	} else {
		result = _swaggerDef_api_api_proto
	}
	return result
}

// RegisterHTTP registers this service's HTTP handlers/bindings.
func (d *DatabaseDesc) RegisterHTTP(mux transport.Router) {

}

// MonitorDesc is a descriptor/registrator for the MonitorServer.
type MonitorDesc struct {
	svc  MonitorServer
	opts httptransport.DescOptions
}

// NewMonitorServiceDesc creates new registrator for the MonitorServer.
// It implements httptransport.ConfigurableServiceDesc as well.
func NewMonitorServiceDesc(svc MonitorServer) *MonitorDesc {
	return &MonitorDesc{
		svc: svc,
	}
}

// RegisterGRPC implements service registrator interface.
func (d *MonitorDesc) RegisterGRPC(s *grpc.Server) {
	RegisterMonitorServer(s, d.svc)
}

// Apply applies passed options.
func (d *MonitorDesc) Apply(oo ...transport.DescOption) {
	for _, o := range oo {
		o.Apply(&d.opts)
	}
}

// SwaggerDef returns this file's Swagger definition.
func (d *MonitorDesc) SwaggerDef(options ...swagger.Option) (result []byte) {
	if len(options) > 0 || len(d.opts.SwaggerDefaultOpts) > 0 {
		var err error
		var s = &spec.Swagger{}
		if err = s.UnmarshalJSON(_swaggerDef_api_api_proto); err != nil {
			panic("Bad swagger definition: " + err.Error())
		}

		for _, o := range d.opts.SwaggerDefaultOpts {
			o(s)
		}
		for _, o := range options {
			o(s)
		}
		if result, err = s.MarshalJSON(); err != nil {
			panic("Failed marshal spec.Swagger definition: " + err.Error())
		}
	} else {
		result = _swaggerDef_api_api_proto
	}
	return result
}

// RegisterHTTP registers this service's HTTP handlers/bindings.
func (d *MonitorDesc) RegisterHTTP(mux transport.Router) {
	chiMux, isChi := mux.(chi.Router)

	{
		// Handler for GetStatsInfo, binding: POST /monitor/getstatsinfo
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Monitor_GetStatsInfo_0(r)
			rsp, err := _Monitor_GetStatsInfo_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_Monitor_GetStatsInfo_0, h)
		} else {
			mux.Handle(pattern_goclay_Monitor_GetStatsInfo_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}
	{
		// Handler for GetStatsInfo, binding: GET /monitor/getstatsinfo
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_Monitor_GetStatsInfo_1(r)
			rsp, err := _Monitor_GetStatsInfo_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_Monitor_GetStatsInfo_1, h)
		} else {
			mux.Handle(pattern_goclay_Monitor_GetStatsInfo_1, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

}

type Wallet_httpClient struct {
	c    *http.Client
	host string
}

// NewWalletHTTPClient creates new HTTP client for WalletServer.
// Pass addr in format "http://host[:port]".
func NewWalletHTTPClient(c *http.Client, addr string) *Wallet_httpClient {
	if strings.HasSuffix(addr, "/") {
		addr = addr[:len(addr)-1]
	}
	return &Wallet_httpClient{c: c, host: addr}
}

func (c *Wallet_httpClient) GetAccount(ctx context.Context, in *core.Account, opts ...grpc.CallOption) (*core.Account, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetAccount_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Account{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetAccountById(ctx context.Context, in *core.Account, opts ...grpc.CallOption) (*core.Account, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetAccountById_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Account{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetAccountBalance(ctx context.Context, in *contract.AccountBalanceRequest, opts ...grpc.CallOption) (*contract.AccountBalanceResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetAccountBalance_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := contract.AccountBalanceResponse{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetBlockBalanceTrace(ctx context.Context, in *contract.BlockBalanceTrace_BlockIdentifier, opts ...grpc.CallOption) (*contract.BlockBalanceTrace, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetBlockBalanceTrace_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := contract.BlockBalanceTrace{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) CreateTransaction(ctx context.Context, in *contract.TransferContract, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_CreateTransaction_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) BroadcastTransaction(ctx context.Context, in *core.Transaction, opts ...grpc.CallOption) (*Return, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_BroadcastTransaction_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := Return{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) UpdateAccount(ctx context.Context, in *contract.AccountUpdateContract, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_UpdateAccount_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) SetAccountId(ctx context.Context, in *contract.SetAccountIdContract, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_SetAccountId_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) VoteWitnessAccount(ctx context.Context, in *contract.VoteWitnessContract, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_VoteWitnessAccount_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) CreateAssetIssue(ctx context.Context, in *contract.AssetIssueContract, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_CreateAssetIssue_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) UpdateWitness(ctx context.Context, in *contract.WitnessUpdateContract, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_UpdateWitness_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) CreateAccount(ctx context.Context, in *contract.AccountCreateContract, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_CreateAccount_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) CreateWitness(ctx context.Context, in *contract.WitnessCreateContract, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_CreateWitness_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) TransferAsset(ctx context.Context, in *contract.TransferAssetContract, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_TransferAsset_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) ParticipateAssetIssue(ctx context.Context, in *contract.ParticipateAssetIssueContract, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_ParticipateAssetIssue_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) FreezeBalance(ctx context.Context, in *contract.FreezeBalanceContract, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_FreezeBalance_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) UnfreezeBalance(ctx context.Context, in *contract.UnfreezeBalanceContract, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_UnfreezeBalance_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) UnfreezeAsset(ctx context.Context, in *contract.UnfreezeAssetContract, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_UnfreezeAsset_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) WithdrawBalance(ctx context.Context, in *contract.WithdrawBalanceContract, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_WithdrawBalance_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) UpdateAsset(ctx context.Context, in *contract.UpdateAssetContract, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_UpdateAsset_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) ListNodes(ctx context.Context, in *EmptyMessage, opts ...grpc.CallOption) (*NodeList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_ListNodes_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := NodeList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetAssetIssueByAccount(ctx context.Context, in *core.Account, opts ...grpc.CallOption) (*AssetIssueList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetAssetIssueByAccount_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := AssetIssueList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetAccountNet(ctx context.Context, in *core.Account, opts ...grpc.CallOption) (*AccountNetMessage, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetAccountNet_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := AccountNetMessage{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetAssetIssueByName(ctx context.Context, in *BytesMessage, opts ...grpc.CallOption) (*contract.AssetIssueContract, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetAssetIssueByName_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := contract.AssetIssueContract{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetNowBlock(ctx context.Context, in *EmptyMessage, opts ...grpc.CallOption) (*core.Block, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetNowBlock_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Block{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetBlockByNum(ctx context.Context, in *NumberMessage, opts ...grpc.CallOption) (*core.Block, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetBlockByNum_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Block{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetBlockById(ctx context.Context, in *BytesMessage, opts ...grpc.CallOption) (*core.Block, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetBlockById_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Block{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetBlockByLimitNext(ctx context.Context, in *BlockLimit, opts ...grpc.CallOption) (*BlockList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetBlockByLimitNext_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := BlockList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetBlockByLatestNum(ctx context.Context, in *NumberMessage, opts ...grpc.CallOption) (*BlockList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetBlockByLatestNum_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := BlockList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetTransactionById(ctx context.Context, in *BytesMessage, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetTransactionById_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) ListWitnesses(ctx context.Context, in *EmptyMessage, opts ...grpc.CallOption) (*WitnessList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_ListWitnesses_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := WitnessList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) ListProposals(ctx context.Context, in *EmptyMessage, opts ...grpc.CallOption) (*ProposalList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_ListProposals_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := ProposalList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetPaginatedProposalList(ctx context.Context, in *PaginatedMessage, opts ...grpc.CallOption) (*ProposalList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetPaginatedProposalList_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := ProposalList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetProposalById(ctx context.Context, in *BytesMessage, opts ...grpc.CallOption) (*core.Proposal, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetProposalById_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Proposal{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) ListExchanges(ctx context.Context, in *EmptyMessage, opts ...grpc.CallOption) (*ExchangeList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_ListExchanges_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := ExchangeList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetPaginatedExchangeList(ctx context.Context, in *PaginatedMessage, opts ...grpc.CallOption) (*ExchangeList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetPaginatedExchangeList_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := ExchangeList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetExchangeById(ctx context.Context, in *BytesMessage, opts ...grpc.CallOption) (*core.Exchange, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetExchangeById_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Exchange{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetChainParameters(ctx context.Context, in *EmptyMessage, opts ...grpc.CallOption) (*core.ChainParameters, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetChainParameters_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.ChainParameters{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetAssetIssueList(ctx context.Context, in *EmptyMessage, opts ...grpc.CallOption) (*AssetIssueList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetAssetIssueList_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := AssetIssueList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetPaginatedAssetIssueList(ctx context.Context, in *PaginatedMessage, opts ...grpc.CallOption) (*AssetIssueList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetPaginatedAssetIssueList_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := AssetIssueList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) TotalTransaction(ctx context.Context, in *EmptyMessage, opts ...grpc.CallOption) (*NumberMessage, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_TotalTransaction_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := NumberMessage{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetNextMaintenanceTime(ctx context.Context, in *EmptyMessage, opts ...grpc.CallOption) (*NumberMessage, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetNextMaintenanceTime_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := NumberMessage{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) GetTransactionInfoById(ctx context.Context, in *BytesMessage, opts ...grpc.CallOption) (*core.TransactionInfo, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_GetTransactionInfoById_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.TransactionInfo{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *Wallet_httpClient) AccountPermissionUpdate(ctx context.Context, in *contract.AccountPermissionUpdateContract, opts ...grpc.CallOption) (*TransactionExtention, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Wallet_AccountPermissionUpdate_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := TransactionExtention{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

type WalletSolidity_httpClient struct {
	c    *http.Client
	host string
}

// NewWalletSolidityHTTPClient creates new HTTP client for WalletSolidityServer.
// Pass addr in format "http://host[:port]".
func NewWalletSolidityHTTPClient(c *http.Client, addr string) *WalletSolidity_httpClient {
	if strings.HasSuffix(addr, "/") {
		addr = addr[:len(addr)-1]
	}
	return &WalletSolidity_httpClient{c: c, host: addr}
}

func (c *WalletSolidity_httpClient) GetAccount(ctx context.Context, in *core.Account, opts ...grpc.CallOption) (*core.Account, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_WalletSolidity_GetAccount_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Account{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *WalletSolidity_httpClient) GetAccountById(ctx context.Context, in *core.Account, opts ...grpc.CallOption) (*core.Account, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_WalletSolidity_GetAccountById_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Account{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *WalletSolidity_httpClient) ListWitnesses(ctx context.Context, in *EmptyMessage, opts ...grpc.CallOption) (*WitnessList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_WalletSolidity_ListWitnesses_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := WitnessList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *WalletSolidity_httpClient) GetAssetIssueList(ctx context.Context, in *EmptyMessage, opts ...grpc.CallOption) (*AssetIssueList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_WalletSolidity_GetAssetIssueList_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := AssetIssueList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *WalletSolidity_httpClient) GetPaginatedAssetIssueList(ctx context.Context, in *PaginatedMessage, opts ...grpc.CallOption) (*AssetIssueList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_WalletSolidity_GetPaginatedAssetIssueList_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := AssetIssueList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *WalletSolidity_httpClient) GetNowBlock(ctx context.Context, in *EmptyMessage, opts ...grpc.CallOption) (*core.Block, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_WalletSolidity_GetNowBlock_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Block{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *WalletSolidity_httpClient) GetBlockByNum(ctx context.Context, in *NumberMessage, opts ...grpc.CallOption) (*core.Block, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_WalletSolidity_GetBlockByNum_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Block{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *WalletSolidity_httpClient) GetTransactionById(ctx context.Context, in *BytesMessage, opts ...grpc.CallOption) (*core.Transaction, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_WalletSolidity_GetTransactionById_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.Transaction{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *WalletSolidity_httpClient) GetTransactionInfoById(ctx context.Context, in *BytesMessage, opts ...grpc.CallOption) (*core.TransactionInfo, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_WalletSolidity_GetTransactionInfoById_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.TransactionInfo{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

type WalletExtension_httpClient struct {
	c    *http.Client
	host string
}

// NewWalletExtensionHTTPClient creates new HTTP client for WalletExtensionServer.
// Pass addr in format "http://host[:port]".
func NewWalletExtensionHTTPClient(c *http.Client, addr string) *WalletExtension_httpClient {
	if strings.HasSuffix(addr, "/") {
		addr = addr[:len(addr)-1]
	}
	return &WalletExtension_httpClient{c: c, host: addr}
}

func (c *WalletExtension_httpClient) GetTransactionsFromThis(ctx context.Context, in *AccountPaginated, opts ...grpc.CallOption) (*TransactionList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_WalletExtension_GetTransactionsFromThis_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := TransactionList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *WalletExtension_httpClient) GetTransactionsToThis(ctx context.Context, in *AccountPaginated, opts ...grpc.CallOption) (*TransactionList, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_WalletExtension_GetTransactionsToThis_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := TransactionList{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

type Monitor_httpClient struct {
	c    *http.Client
	host string
}

// NewMonitorHTTPClient creates new HTTP client for MonitorServer.
// Pass addr in format "http://host[:port]".
func NewMonitorHTTPClient(c *http.Client, addr string) *Monitor_httpClient {
	if strings.HasSuffix(addr, "/") {
		addr = addr[:len(addr)-1]
	}
	return &Monitor_httpClient{c: c, host: addr}
}

func (c *Monitor_httpClient) GetStatsInfo(ctx context.Context, in *EmptyMessage, opts ...grpc.CallOption) (*core.MetricsInfo, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_Monitor_GetStatsInfo_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := core.MetricsInfo{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

// patterns for Wallet
var (
	pattern_goclay_Wallet_GetAccount_0 = "/wallet/getaccount"

	pattern_goclay_Wallet_GetAccount_0_builder = func(in *core.Account) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getaccount"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetAccount_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetAccount_1 = "/wallet/getaccount"

	pattern_goclay_Wallet_GetAccount_1_builder = func(in *core.Account) string {
		values := url.Values{}
		values.Add("account_name", base64.StdEncoding.EncodeToString(in.AccountName))
		values.Add("type", fmt.Sprintf("%s", in.Type))
		values.Add("address", base64.StdEncoding.EncodeToString(in.Address))
		values.Add("balance", fmt.Sprintf("%d", in.Balance))

		values.Add("net_usage", fmt.Sprintf("%d", in.NetUsage))
		values.Add("acquired_delegated_frozen_balance_for_bandwidth", fmt.Sprintf("%d", in.AcquiredDelegatedFrozenBalanceForBandwidth))
		values.Add("delegated_frozen_balance_for_bandwidth", fmt.Sprintf("%d", in.DelegatedFrozenBalanceForBandwidth))
		values.Add("old_tron_power", fmt.Sprintf("%d", in.OldTronPower))

		values.Add("asset_optimized", fmt.Sprintf("%t", in.AssetOptimized))
		values.Add("create_time", fmt.Sprintf("%d", in.CreateTime))
		values.Add("latest_opration_time", fmt.Sprintf("%d", in.LatestOprationTime))
		values.Add("allowance", fmt.Sprintf("%d", in.Allowance))
		values.Add("latest_withdraw_time", fmt.Sprintf("%d", in.LatestWithdrawTime))
		values.Add("code", base64.StdEncoding.EncodeToString(in.Code))
		values.Add("is_witness", fmt.Sprintf("%t", in.IsWitness))
		values.Add("is_committee", fmt.Sprintf("%t", in.IsCommittee))

		values.Add("asset_issued_name", base64.StdEncoding.EncodeToString(in.AssetIssuedName))
		values.Add("asset_issued_ID", base64.StdEncoding.EncodeToString(in.AssetIssued_ID))

		values.Add("free_net_usage", fmt.Sprintf("%d", in.FreeNetUsage))

		values.Add("latest_consume_time", fmt.Sprintf("%d", in.LatestConsumeTime))
		values.Add("latest_consume_free_time", fmt.Sprintf("%d", in.LatestConsumeFreeTime))
		values.Add("account_id", base64.StdEncoding.EncodeToString(in.AccountId))
		values.Add("net_window_size", fmt.Sprintf("%d", in.NetWindowSize))
		values.Add("net_window_optimized", fmt.Sprintf("%t", in.NetWindowOptimized))

		values.Add("codeHash", base64.StdEncoding.EncodeToString(in.CodeHash))

		values.Add("delegated_frozenV2_balance_for_bandwidth", fmt.Sprintf("%d", in.DelegatedFrozenV2BalanceForBandwidth))
		values.Add("acquired_delegated_frozenV2_balance_for_bandwidth", fmt.Sprintf("%d", in.AcquiredDelegatedFrozenV2BalanceForBandwidth))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getaccount"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetAccount_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetAccountById_0 = "/wallet/getaccountbyid"

	pattern_goclay_Wallet_GetAccountById_0_builder = func(in *core.Account) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getaccountbyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetAccountById_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetAccountById_1 = "/wallet/getaccountbyid"

	pattern_goclay_Wallet_GetAccountById_1_builder = func(in *core.Account) string {
		values := url.Values{}
		values.Add("account_name", base64.StdEncoding.EncodeToString(in.AccountName))
		values.Add("type", fmt.Sprintf("%s", in.Type))
		values.Add("address", base64.StdEncoding.EncodeToString(in.Address))
		values.Add("balance", fmt.Sprintf("%d", in.Balance))

		values.Add("net_usage", fmt.Sprintf("%d", in.NetUsage))
		values.Add("acquired_delegated_frozen_balance_for_bandwidth", fmt.Sprintf("%d", in.AcquiredDelegatedFrozenBalanceForBandwidth))
		values.Add("delegated_frozen_balance_for_bandwidth", fmt.Sprintf("%d", in.DelegatedFrozenBalanceForBandwidth))
		values.Add("old_tron_power", fmt.Sprintf("%d", in.OldTronPower))

		values.Add("asset_optimized", fmt.Sprintf("%t", in.AssetOptimized))
		values.Add("create_time", fmt.Sprintf("%d", in.CreateTime))
		values.Add("latest_opration_time", fmt.Sprintf("%d", in.LatestOprationTime))
		values.Add("allowance", fmt.Sprintf("%d", in.Allowance))
		values.Add("latest_withdraw_time", fmt.Sprintf("%d", in.LatestWithdrawTime))
		values.Add("code", base64.StdEncoding.EncodeToString(in.Code))
		values.Add("is_witness", fmt.Sprintf("%t", in.IsWitness))
		values.Add("is_committee", fmt.Sprintf("%t", in.IsCommittee))

		values.Add("asset_issued_name", base64.StdEncoding.EncodeToString(in.AssetIssuedName))
		values.Add("asset_issued_ID", base64.StdEncoding.EncodeToString(in.AssetIssued_ID))

		values.Add("free_net_usage", fmt.Sprintf("%d", in.FreeNetUsage))

		values.Add("latest_consume_time", fmt.Sprintf("%d", in.LatestConsumeTime))
		values.Add("latest_consume_free_time", fmt.Sprintf("%d", in.LatestConsumeFreeTime))
		values.Add("account_id", base64.StdEncoding.EncodeToString(in.AccountId))
		values.Add("net_window_size", fmt.Sprintf("%d", in.NetWindowSize))
		values.Add("net_window_optimized", fmt.Sprintf("%t", in.NetWindowOptimized))

		values.Add("codeHash", base64.StdEncoding.EncodeToString(in.CodeHash))

		values.Add("delegated_frozenV2_balance_for_bandwidth", fmt.Sprintf("%d", in.DelegatedFrozenV2BalanceForBandwidth))
		values.Add("acquired_delegated_frozenV2_balance_for_bandwidth", fmt.Sprintf("%d", in.AcquiredDelegatedFrozenV2BalanceForBandwidth))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getaccountbyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetAccountById_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetAccountBalance_0 = "/wallet/getaccountbalance"

	pattern_goclay_Wallet_GetAccountBalance_0_builder = func(in *contract.AccountBalanceRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getaccountbalance"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetAccountBalance_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetAccountBalance_1 = "/wallet/getaccountbalance"

	pattern_goclay_Wallet_GetAccountBalance_1_builder = func(in *contract.AccountBalanceRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getaccountbalance"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetAccountBalance_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetBlockBalanceTrace_0 = "/wallet/getblockbalancetrace"

	pattern_goclay_Wallet_GetBlockBalanceTrace_0_builder = func(in *contract.BlockBalanceTrace_BlockIdentifier) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getblockbalancetrace"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetBlockBalanceTrace_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetBlockBalanceTrace_1 = "/wallet/getblockbalancetrace"

	pattern_goclay_Wallet_GetBlockBalanceTrace_1_builder = func(in *contract.BlockBalanceTrace_BlockIdentifier) string {
		values := url.Values{}
		values.Add("hash", base64.StdEncoding.EncodeToString(in.Hash))
		values.Add("number", fmt.Sprintf("%d", in.Number))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getblockbalancetrace"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetBlockBalanceTrace_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_CreateTransaction_0 = "/wallet/createtransaction"

	pattern_goclay_Wallet_CreateTransaction_0_builder = func(in *contract.TransferContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/createtransaction"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_CreateTransaction_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_CreateTransaction_1 = "/wallet/createtransaction"

	pattern_goclay_Wallet_CreateTransaction_1_builder = func(in *contract.TransferContract) string {
		values := url.Values{}
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))
		values.Add("to_address", base64.StdEncoding.EncodeToString(in.ToAddress))
		values.Add("amount", fmt.Sprintf("%d", in.Amount))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/createtransaction"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_CreateTransaction_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_BroadcastTransaction_0 = "/wallet/broadcasttransaction"

	pattern_goclay_Wallet_BroadcastTransaction_0_builder = func(in *core.Transaction) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/broadcasttransaction"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_BroadcastTransaction_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_BroadcastTransaction_1 = "/wallet/broadcasttransaction"

	pattern_goclay_Wallet_BroadcastTransaction_1_builder = func(in *core.Transaction) string {
		values := url.Values{}

		for _, v := range in.Signature {
			values.Add("signature", base64.StdEncoding.EncodeToString(v))
		}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/broadcasttransaction"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_BroadcastTransaction_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_UpdateAccount_0 = "/wallet/updateaccount"

	pattern_goclay_Wallet_UpdateAccount_0_builder = func(in *contract.AccountUpdateContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/updateaccount"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_UpdateAccount_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_UpdateAccount_1 = "/wallet/updateaccount"

	pattern_goclay_Wallet_UpdateAccount_1_builder = func(in *contract.AccountUpdateContract) string {
		values := url.Values{}
		values.Add("account_name", base64.StdEncoding.EncodeToString(in.AccountName))
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/updateaccount"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_UpdateAccount_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_SetAccountId_0 = "/wallet/setaccountid"

	pattern_goclay_Wallet_SetAccountId_0_builder = func(in *contract.SetAccountIdContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/setaccountid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_SetAccountId_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_SetAccountId_1 = "/wallet/setaccountid"

	pattern_goclay_Wallet_SetAccountId_1_builder = func(in *contract.SetAccountIdContract) string {
		values := url.Values{}
		values.Add("account_id", base64.StdEncoding.EncodeToString(in.AccountId))
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/setaccountid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_SetAccountId_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_VoteWitnessAccount_0 = "/wallet/votewitnessaccount"

	pattern_goclay_Wallet_VoteWitnessAccount_0_builder = func(in *contract.VoteWitnessContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/votewitnessaccount"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_VoteWitnessAccount_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_VoteWitnessAccount_1 = "/wallet/votewitnessaccount"

	pattern_goclay_Wallet_VoteWitnessAccount_1_builder = func(in *contract.VoteWitnessContract) string {
		values := url.Values{}
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))

		values.Add("support", fmt.Sprintf("%t", in.Support))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/votewitnessaccount"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_VoteWitnessAccount_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_CreateAssetIssue_0 = "/wallet/createassetissue"

	pattern_goclay_Wallet_CreateAssetIssue_0_builder = func(in *contract.AssetIssueContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/createassetissue"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_CreateAssetIssue_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_CreateAssetIssue_1 = "/wallet/createassetissue"

	pattern_goclay_Wallet_CreateAssetIssue_1_builder = func(in *contract.AssetIssueContract) string {
		values := url.Values{}
		values.Add("id", fmt.Sprintf("%s", in.Id))
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))
		values.Add("name", base64.StdEncoding.EncodeToString(in.Name))
		values.Add("abbr", base64.StdEncoding.EncodeToString(in.Abbr))
		values.Add("total_supply", fmt.Sprintf("%d", in.TotalSupply))

		values.Add("trx_num", fmt.Sprintf("%d", in.TrxNum))
		values.Add("precision", fmt.Sprintf("%d", in.Precision))
		values.Add("num", fmt.Sprintf("%d", in.Num))
		values.Add("start_time", fmt.Sprintf("%d", in.StartTime))
		values.Add("end_time", fmt.Sprintf("%d", in.EndTime))
		values.Add("order", fmt.Sprintf("%d", in.Order))
		values.Add("vote_score", fmt.Sprintf("%d", in.VoteScore))
		values.Add("description", base64.StdEncoding.EncodeToString(in.Description))
		values.Add("url", base64.StdEncoding.EncodeToString(in.Url))
		values.Add("free_asset_net_limit", fmt.Sprintf("%d", in.FreeAssetNetLimit))
		values.Add("public_free_asset_net_limit", fmt.Sprintf("%d", in.PublicFreeAssetNetLimit))
		values.Add("public_free_asset_net_usage", fmt.Sprintf("%d", in.PublicFreeAssetNetUsage))
		values.Add("public_latest_free_net_time", fmt.Sprintf("%d", in.PublicLatestFreeNetTime))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/createassetissue"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_CreateAssetIssue_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_UpdateWitness_0 = "/wallet/updatewitness"

	pattern_goclay_Wallet_UpdateWitness_0_builder = func(in *contract.WitnessUpdateContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/updatewitness"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_UpdateWitness_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_UpdateWitness_1 = "/wallet/updatewitness"

	pattern_goclay_Wallet_UpdateWitness_1_builder = func(in *contract.WitnessUpdateContract) string {
		values := url.Values{}
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))
		values.Add("update_url", base64.StdEncoding.EncodeToString(in.UpdateUrl))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/updatewitness"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_UpdateWitness_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_CreateAccount_0 = "/wallet/createaccount"

	pattern_goclay_Wallet_CreateAccount_0_builder = func(in *contract.AccountCreateContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/createaccount"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_CreateAccount_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_CreateAccount_1 = "/wallet/createaccount"

	pattern_goclay_Wallet_CreateAccount_1_builder = func(in *contract.AccountCreateContract) string {
		values := url.Values{}
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))
		values.Add("account_address", base64.StdEncoding.EncodeToString(in.AccountAddress))
		values.Add("type", fmt.Sprintf("%s", in.Type))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/createaccount"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_CreateAccount_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_CreateWitness_0 = "/wallet/createwitness"

	pattern_goclay_Wallet_CreateWitness_0_builder = func(in *contract.WitnessCreateContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/createwitness"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_CreateWitness_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_CreateWitness_1 = "/wallet/createwitness"

	pattern_goclay_Wallet_CreateWitness_1_builder = func(in *contract.WitnessCreateContract) string {
		values := url.Values{}
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))
		values.Add("url", base64.StdEncoding.EncodeToString(in.Url))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/createwitness"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_CreateWitness_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_TransferAsset_0 = "/wallet/transferasset"

	pattern_goclay_Wallet_TransferAsset_0_builder = func(in *contract.TransferAssetContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/transferasset"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_TransferAsset_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_TransferAsset_1 = "/wallet/transferasset"

	pattern_goclay_Wallet_TransferAsset_1_builder = func(in *contract.TransferAssetContract) string {
		values := url.Values{}
		values.Add("asset_name", base64.StdEncoding.EncodeToString(in.AssetName))
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))
		values.Add("to_address", base64.StdEncoding.EncodeToString(in.ToAddress))
		values.Add("amount", fmt.Sprintf("%d", in.Amount))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/transferasset"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_TransferAsset_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_ParticipateAssetIssue_0 = "/wallet/participateassetissue"

	pattern_goclay_Wallet_ParticipateAssetIssue_0_builder = func(in *contract.ParticipateAssetIssueContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/participateassetissue"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_ParticipateAssetIssue_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_ParticipateAssetIssue_1 = "/wallet/participateassetissue"

	pattern_goclay_Wallet_ParticipateAssetIssue_1_builder = func(in *contract.ParticipateAssetIssueContract) string {
		values := url.Values{}
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))
		values.Add("to_address", base64.StdEncoding.EncodeToString(in.ToAddress))
		values.Add("asset_name", base64.StdEncoding.EncodeToString(in.AssetName))
		values.Add("amount", fmt.Sprintf("%d", in.Amount))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/participateassetissue"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_ParticipateAssetIssue_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_FreezeBalance_0 = "/wallet/freezebalance"

	pattern_goclay_Wallet_FreezeBalance_0_builder = func(in *contract.FreezeBalanceContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/freezebalance"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_FreezeBalance_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_FreezeBalance_1 = "/wallet/freezebalance"

	pattern_goclay_Wallet_FreezeBalance_1_builder = func(in *contract.FreezeBalanceContract) string {
		values := url.Values{}
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))
		values.Add("frozen_balance", fmt.Sprintf("%d", in.FrozenBalance))
		values.Add("frozen_duration", fmt.Sprintf("%d", in.FrozenDuration))
		values.Add("resource", fmt.Sprintf("%s", in.Resource))
		values.Add("receiver_address", base64.StdEncoding.EncodeToString(in.ReceiverAddress))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/freezebalance"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_FreezeBalance_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_UnfreezeBalance_0 = "/wallet/unfreezebalance"

	pattern_goclay_Wallet_UnfreezeBalance_0_builder = func(in *contract.UnfreezeBalanceContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/unfreezebalance"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_UnfreezeBalance_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_UnfreezeBalance_1 = "/wallet/unfreezebalance"

	pattern_goclay_Wallet_UnfreezeBalance_1_builder = func(in *contract.UnfreezeBalanceContract) string {
		values := url.Values{}
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))
		values.Add("resource", fmt.Sprintf("%s", in.Resource))
		values.Add("receiver_address", base64.StdEncoding.EncodeToString(in.ReceiverAddress))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/unfreezebalance"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_UnfreezeBalance_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_UnfreezeAsset_0 = "/wallet/unfreezeasset"

	pattern_goclay_Wallet_UnfreezeAsset_0_builder = func(in *contract.UnfreezeAssetContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/unfreezeasset"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_UnfreezeAsset_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_UnfreezeAsset_1 = "/wallet/unfreezeasset"

	pattern_goclay_Wallet_UnfreezeAsset_1_builder = func(in *contract.UnfreezeAssetContract) string {
		values := url.Values{}
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/unfreezeasset"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_UnfreezeAsset_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_WithdrawBalance_0 = "/wallet/withdrawbalance"

	pattern_goclay_Wallet_WithdrawBalance_0_builder = func(in *contract.WithdrawBalanceContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/withdrawbalance"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_WithdrawBalance_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_WithdrawBalance_1 = "/wallet/withdrawbalance"

	pattern_goclay_Wallet_WithdrawBalance_1_builder = func(in *contract.WithdrawBalanceContract) string {
		values := url.Values{}
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/withdrawbalance"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_WithdrawBalance_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_UpdateAsset_0 = "/wallet/updateasset"

	pattern_goclay_Wallet_UpdateAsset_0_builder = func(in *contract.UpdateAssetContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/updateasset"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_UpdateAsset_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_UpdateAsset_1 = "/wallet/updateasset"

	pattern_goclay_Wallet_UpdateAsset_1_builder = func(in *contract.UpdateAssetContract) string {
		values := url.Values{}
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))
		values.Add("description", base64.StdEncoding.EncodeToString(in.Description))
		values.Add("url", base64.StdEncoding.EncodeToString(in.Url))
		values.Add("new_limit", fmt.Sprintf("%d", in.NewLimit))
		values.Add("new_public_limit", fmt.Sprintf("%d", in.NewPublicLimit))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/updateasset"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_UpdateAsset_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_ListNodes_0 = "/wallet/listnodes"

	pattern_goclay_Wallet_ListNodes_0_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/listnodes"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_ListNodes_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_ListNodes_1 = "/wallet/listnodes"

	pattern_goclay_Wallet_ListNodes_1_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/listnodes"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_ListNodes_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetAssetIssueByAccount_0 = "/wallet/getassetissuebyaccount"

	pattern_goclay_Wallet_GetAssetIssueByAccount_0_builder = func(in *core.Account) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getassetissuebyaccount"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetAssetIssueByAccount_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetAssetIssueByAccount_1 = "/wallet/getassetissuebyaccount"

	pattern_goclay_Wallet_GetAssetIssueByAccount_1_builder = func(in *core.Account) string {
		values := url.Values{}
		values.Add("account_name", base64.StdEncoding.EncodeToString(in.AccountName))
		values.Add("type", fmt.Sprintf("%s", in.Type))
		values.Add("address", base64.StdEncoding.EncodeToString(in.Address))
		values.Add("balance", fmt.Sprintf("%d", in.Balance))

		values.Add("net_usage", fmt.Sprintf("%d", in.NetUsage))
		values.Add("acquired_delegated_frozen_balance_for_bandwidth", fmt.Sprintf("%d", in.AcquiredDelegatedFrozenBalanceForBandwidth))
		values.Add("delegated_frozen_balance_for_bandwidth", fmt.Sprintf("%d", in.DelegatedFrozenBalanceForBandwidth))
		values.Add("old_tron_power", fmt.Sprintf("%d", in.OldTronPower))

		values.Add("asset_optimized", fmt.Sprintf("%t", in.AssetOptimized))
		values.Add("create_time", fmt.Sprintf("%d", in.CreateTime))
		values.Add("latest_opration_time", fmt.Sprintf("%d", in.LatestOprationTime))
		values.Add("allowance", fmt.Sprintf("%d", in.Allowance))
		values.Add("latest_withdraw_time", fmt.Sprintf("%d", in.LatestWithdrawTime))
		values.Add("code", base64.StdEncoding.EncodeToString(in.Code))
		values.Add("is_witness", fmt.Sprintf("%t", in.IsWitness))
		values.Add("is_committee", fmt.Sprintf("%t", in.IsCommittee))

		values.Add("asset_issued_name", base64.StdEncoding.EncodeToString(in.AssetIssuedName))
		values.Add("asset_issued_ID", base64.StdEncoding.EncodeToString(in.AssetIssued_ID))

		values.Add("free_net_usage", fmt.Sprintf("%d", in.FreeNetUsage))

		values.Add("latest_consume_time", fmt.Sprintf("%d", in.LatestConsumeTime))
		values.Add("latest_consume_free_time", fmt.Sprintf("%d", in.LatestConsumeFreeTime))
		values.Add("account_id", base64.StdEncoding.EncodeToString(in.AccountId))
		values.Add("net_window_size", fmt.Sprintf("%d", in.NetWindowSize))
		values.Add("net_window_optimized", fmt.Sprintf("%t", in.NetWindowOptimized))

		values.Add("codeHash", base64.StdEncoding.EncodeToString(in.CodeHash))

		values.Add("delegated_frozenV2_balance_for_bandwidth", fmt.Sprintf("%d", in.DelegatedFrozenV2BalanceForBandwidth))
		values.Add("acquired_delegated_frozenV2_balance_for_bandwidth", fmt.Sprintf("%d", in.AcquiredDelegatedFrozenV2BalanceForBandwidth))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getassetissuebyaccount"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetAssetIssueByAccount_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetAccountNet_0 = "/wallet/getaccountnet"

	pattern_goclay_Wallet_GetAccountNet_0_builder = func(in *core.Account) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getaccountnet"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetAccountNet_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetAccountNet_1 = "/wallet/getaccountnet"

	pattern_goclay_Wallet_GetAccountNet_1_builder = func(in *core.Account) string {
		values := url.Values{}
		values.Add("account_name", base64.StdEncoding.EncodeToString(in.AccountName))
		values.Add("type", fmt.Sprintf("%s", in.Type))
		values.Add("address", base64.StdEncoding.EncodeToString(in.Address))
		values.Add("balance", fmt.Sprintf("%d", in.Balance))

		values.Add("net_usage", fmt.Sprintf("%d", in.NetUsage))
		values.Add("acquired_delegated_frozen_balance_for_bandwidth", fmt.Sprintf("%d", in.AcquiredDelegatedFrozenBalanceForBandwidth))
		values.Add("delegated_frozen_balance_for_bandwidth", fmt.Sprintf("%d", in.DelegatedFrozenBalanceForBandwidth))
		values.Add("old_tron_power", fmt.Sprintf("%d", in.OldTronPower))

		values.Add("asset_optimized", fmt.Sprintf("%t", in.AssetOptimized))
		values.Add("create_time", fmt.Sprintf("%d", in.CreateTime))
		values.Add("latest_opration_time", fmt.Sprintf("%d", in.LatestOprationTime))
		values.Add("allowance", fmt.Sprintf("%d", in.Allowance))
		values.Add("latest_withdraw_time", fmt.Sprintf("%d", in.LatestWithdrawTime))
		values.Add("code", base64.StdEncoding.EncodeToString(in.Code))
		values.Add("is_witness", fmt.Sprintf("%t", in.IsWitness))
		values.Add("is_committee", fmt.Sprintf("%t", in.IsCommittee))

		values.Add("asset_issued_name", base64.StdEncoding.EncodeToString(in.AssetIssuedName))
		values.Add("asset_issued_ID", base64.StdEncoding.EncodeToString(in.AssetIssued_ID))

		values.Add("free_net_usage", fmt.Sprintf("%d", in.FreeNetUsage))

		values.Add("latest_consume_time", fmt.Sprintf("%d", in.LatestConsumeTime))
		values.Add("latest_consume_free_time", fmt.Sprintf("%d", in.LatestConsumeFreeTime))
		values.Add("account_id", base64.StdEncoding.EncodeToString(in.AccountId))
		values.Add("net_window_size", fmt.Sprintf("%d", in.NetWindowSize))
		values.Add("net_window_optimized", fmt.Sprintf("%t", in.NetWindowOptimized))

		values.Add("codeHash", base64.StdEncoding.EncodeToString(in.CodeHash))

		values.Add("delegated_frozenV2_balance_for_bandwidth", fmt.Sprintf("%d", in.DelegatedFrozenV2BalanceForBandwidth))
		values.Add("acquired_delegated_frozenV2_balance_for_bandwidth", fmt.Sprintf("%d", in.AcquiredDelegatedFrozenV2BalanceForBandwidth))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getaccountnet"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetAccountNet_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetAssetIssueByName_0 = "/wallet/getassetissuebyname"

	pattern_goclay_Wallet_GetAssetIssueByName_0_builder = func(in *BytesMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getassetissuebyname"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetAssetIssueByName_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetAssetIssueByName_1 = "/wallet/getassetissuebyname"

	pattern_goclay_Wallet_GetAssetIssueByName_1_builder = func(in *BytesMessage) string {
		values := url.Values{}
		values.Add("value", base64.StdEncoding.EncodeToString(in.Value))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getassetissuebyname"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetAssetIssueByName_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetNowBlock_0 = "/wallet/getnowblock"

	pattern_goclay_Wallet_GetNowBlock_0_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getnowblock"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetNowBlock_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetNowBlock_1 = "/wallet/getnowblock"

	pattern_goclay_Wallet_GetNowBlock_1_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getnowblock"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetNowBlock_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetBlockByNum_0 = "/wallet/getblockbynum"

	pattern_goclay_Wallet_GetBlockByNum_0_builder = func(in *NumberMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getblockbynum"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetBlockByNum_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetBlockByNum_1 = "/wallet/getblockbynum"

	pattern_goclay_Wallet_GetBlockByNum_1_builder = func(in *NumberMessage) string {
		values := url.Values{}
		values.Add("num", fmt.Sprintf("%d", in.Num))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getblockbynum"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetBlockByNum_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetBlockById_0 = "/wallet/getblockbyid"

	pattern_goclay_Wallet_GetBlockById_0_builder = func(in *BytesMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getblockbyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetBlockById_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetBlockById_1 = "/wallet/getblockbyid"

	pattern_goclay_Wallet_GetBlockById_1_builder = func(in *BytesMessage) string {
		values := url.Values{}
		values.Add("value", base64.StdEncoding.EncodeToString(in.Value))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getblockbyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetBlockById_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetBlockByLimitNext_0 = "/wallet/getblockbylimitnext"

	pattern_goclay_Wallet_GetBlockByLimitNext_0_builder = func(in *BlockLimit) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getblockbylimitnext"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetBlockByLimitNext_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetBlockByLimitNext_1 = "/wallet/getblockbylimitnext"

	pattern_goclay_Wallet_GetBlockByLimitNext_1_builder = func(in *BlockLimit) string {
		values := url.Values{}
		values.Add("startNum", fmt.Sprintf("%d", in.StartNum))
		values.Add("endNum", fmt.Sprintf("%d", in.EndNum))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getblockbylimitnext"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetBlockByLimitNext_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetBlockByLatestNum_0 = "/wallet/getblockbylatestnum"

	pattern_goclay_Wallet_GetBlockByLatestNum_0_builder = func(in *NumberMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getblockbylatestnum"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetBlockByLatestNum_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetBlockByLatestNum_1 = "/wallet/getblockbylatestnum"

	pattern_goclay_Wallet_GetBlockByLatestNum_1_builder = func(in *NumberMessage) string {
		values := url.Values{}
		values.Add("num", fmt.Sprintf("%d", in.Num))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getblockbylatestnum"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetBlockByLatestNum_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetTransactionById_0 = "/wallet/gettransactionbyid"

	pattern_goclay_Wallet_GetTransactionById_0_builder = func(in *BytesMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/gettransactionbyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetTransactionById_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetTransactionById_1 = "/wallet/gettransactionbyid"

	pattern_goclay_Wallet_GetTransactionById_1_builder = func(in *BytesMessage) string {
		values := url.Values{}
		values.Add("value", base64.StdEncoding.EncodeToString(in.Value))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/gettransactionbyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetTransactionById_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_ListWitnesses_0 = "/wallet/listwitnesses"

	pattern_goclay_Wallet_ListWitnesses_0_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/listwitnesses"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_ListWitnesses_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_ListWitnesses_1 = "/wallet/listwitnesses"

	pattern_goclay_Wallet_ListWitnesses_1_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/listwitnesses"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_ListWitnesses_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_ListProposals_0 = "/wallet/listproposals"

	pattern_goclay_Wallet_ListProposals_0_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/listproposals"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_ListProposals_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_ListProposals_1 = "/wallet/listproposals"

	pattern_goclay_Wallet_ListProposals_1_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/listproposals"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_ListProposals_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetPaginatedProposalList_0 = "/wallet/getpaginatedproposallist"

	pattern_goclay_Wallet_GetPaginatedProposalList_0_builder = func(in *PaginatedMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getpaginatedproposallist"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetPaginatedProposalList_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetPaginatedProposalList_1 = "/wallet/getpaginatedproposallist"

	pattern_goclay_Wallet_GetPaginatedProposalList_1_builder = func(in *PaginatedMessage) string {
		values := url.Values{}
		values.Add("offset", fmt.Sprintf("%d", in.Offset))
		values.Add("limit", fmt.Sprintf("%d", in.Limit))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getpaginatedproposallist"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetPaginatedProposalList_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetProposalById_0 = "/wallet/getproposalbyid"

	pattern_goclay_Wallet_GetProposalById_0_builder = func(in *BytesMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getproposalbyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetProposalById_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetProposalById_1 = "/wallet/getproposalbyid"

	pattern_goclay_Wallet_GetProposalById_1_builder = func(in *BytesMessage) string {
		values := url.Values{}
		values.Add("value", base64.StdEncoding.EncodeToString(in.Value))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getproposalbyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetProposalById_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_ListExchanges_0 = "/wallet/listexchanges"

	pattern_goclay_Wallet_ListExchanges_0_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/listexchanges"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_ListExchanges_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_ListExchanges_1 = "/wallet/listexchanges"

	pattern_goclay_Wallet_ListExchanges_1_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/listexchanges"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_ListExchanges_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetPaginatedExchangeList_0 = "/wallet/getpaginatedexchangelist"

	pattern_goclay_Wallet_GetPaginatedExchangeList_0_builder = func(in *PaginatedMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getpaginatedexchangelist"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetPaginatedExchangeList_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetPaginatedExchangeList_1 = "/wallet/getpaginatedexchangelist"

	pattern_goclay_Wallet_GetPaginatedExchangeList_1_builder = func(in *PaginatedMessage) string {
		values := url.Values{}
		values.Add("offset", fmt.Sprintf("%d", in.Offset))
		values.Add("limit", fmt.Sprintf("%d", in.Limit))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getpaginatedexchangelist"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetPaginatedExchangeList_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetExchangeById_0 = "/wallet/getexchangebyid"

	pattern_goclay_Wallet_GetExchangeById_0_builder = func(in *BytesMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getexchangebyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetExchangeById_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetExchangeById_1 = "/wallet/getexchangebyid"

	pattern_goclay_Wallet_GetExchangeById_1_builder = func(in *BytesMessage) string {
		values := url.Values{}
		values.Add("value", base64.StdEncoding.EncodeToString(in.Value))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getexchangebyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetExchangeById_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetChainParameters_0 = "/wallet/getchainparameters"

	pattern_goclay_Wallet_GetChainParameters_0_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getchainparameters"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetChainParameters_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetChainParameters_1 = "/wallet/getchainparameters"

	pattern_goclay_Wallet_GetChainParameters_1_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getchainparameters"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetChainParameters_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetAssetIssueList_0 = "/wallet/getassetissuelist"

	pattern_goclay_Wallet_GetAssetIssueList_0_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getassetissuelist"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetAssetIssueList_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetAssetIssueList_1 = "/wallet/getassetissuelist"

	pattern_goclay_Wallet_GetAssetIssueList_1_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getassetissuelist"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetAssetIssueList_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetPaginatedAssetIssueList_0 = "/wallet/getpaginatedassetissuelist"

	pattern_goclay_Wallet_GetPaginatedAssetIssueList_0_builder = func(in *PaginatedMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getpaginatedassetissuelist"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetPaginatedAssetIssueList_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetPaginatedAssetIssueList_1 = "/wallet/getpaginatedassetissuelist"

	pattern_goclay_Wallet_GetPaginatedAssetIssueList_1_builder = func(in *PaginatedMessage) string {
		values := url.Values{}
		values.Add("offset", fmt.Sprintf("%d", in.Offset))
		values.Add("limit", fmt.Sprintf("%d", in.Limit))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getpaginatedassetissuelist"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetPaginatedAssetIssueList_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_TotalTransaction_0 = "/wallet/totaltransaction"

	pattern_goclay_Wallet_TotalTransaction_0_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/totaltransaction"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_TotalTransaction_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_TotalTransaction_1 = "/wallet/totaltransaction"

	pattern_goclay_Wallet_TotalTransaction_1_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/totaltransaction"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_TotalTransaction_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetNextMaintenanceTime_0 = "/wallet/getnextmaintenancetime"

	pattern_goclay_Wallet_GetNextMaintenanceTime_0_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getnextmaintenancetime"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetNextMaintenanceTime_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetNextMaintenanceTime_1 = "/wallet/getnextmaintenancetime"

	pattern_goclay_Wallet_GetNextMaintenanceTime_1_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/getnextmaintenancetime"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetNextMaintenanceTime_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_GetTransactionInfoById_0 = "/wallet/gettransactioninfobyid"

	pattern_goclay_Wallet_GetTransactionInfoById_0_builder = func(in *BytesMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/gettransactioninfobyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetTransactionInfoById_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_GetTransactionInfoById_1 = "/wallet/gettransactioninfobyid"

	pattern_goclay_Wallet_GetTransactionInfoById_1_builder = func(in *BytesMessage) string {
		values := url.Values{}
		values.Add("value", base64.StdEncoding.EncodeToString(in.Value))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/gettransactioninfobyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_GetTransactionInfoById_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_Wallet_AccountPermissionUpdate_0 = "/wallet/accountpermissionupdate"

	pattern_goclay_Wallet_AccountPermissionUpdate_0_builder = func(in *contract.AccountPermissionUpdateContract) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/accountpermissionupdate"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_AccountPermissionUpdate_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Wallet_AccountPermissionUpdate_1 = "/wallet/accountpermissionupdate"

	pattern_goclay_Wallet_AccountPermissionUpdate_1_builder = func(in *contract.AccountPermissionUpdateContract) string {
		values := url.Values{}
		values.Add("owner_address", base64.StdEncoding.EncodeToString(in.OwnerAddress))

		u := url.URL{
			Path:     fmt.Sprintf("/wallet/accountpermissionupdate"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Wallet_AccountPermissionUpdate_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
)

// patterns for WalletSolidity
var (
	pattern_goclay_WalletSolidity_GetAccount_0 = "/walletsolidity/getaccount"

	pattern_goclay_WalletSolidity_GetAccount_0_builder = func(in *core.Account) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/getaccount"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetAccount_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_WalletSolidity_GetAccount_1 = "/walletsolidity/getaccount"

	pattern_goclay_WalletSolidity_GetAccount_1_builder = func(in *core.Account) string {
		values := url.Values{}
		values.Add("account_name", base64.StdEncoding.EncodeToString(in.AccountName))
		values.Add("type", fmt.Sprintf("%s", in.Type))
		values.Add("address", base64.StdEncoding.EncodeToString(in.Address))
		values.Add("balance", fmt.Sprintf("%d", in.Balance))

		values.Add("net_usage", fmt.Sprintf("%d", in.NetUsage))
		values.Add("acquired_delegated_frozen_balance_for_bandwidth", fmt.Sprintf("%d", in.AcquiredDelegatedFrozenBalanceForBandwidth))
		values.Add("delegated_frozen_balance_for_bandwidth", fmt.Sprintf("%d", in.DelegatedFrozenBalanceForBandwidth))
		values.Add("old_tron_power", fmt.Sprintf("%d", in.OldTronPower))

		values.Add("asset_optimized", fmt.Sprintf("%t", in.AssetOptimized))
		values.Add("create_time", fmt.Sprintf("%d", in.CreateTime))
		values.Add("latest_opration_time", fmt.Sprintf("%d", in.LatestOprationTime))
		values.Add("allowance", fmt.Sprintf("%d", in.Allowance))
		values.Add("latest_withdraw_time", fmt.Sprintf("%d", in.LatestWithdrawTime))
		values.Add("code", base64.StdEncoding.EncodeToString(in.Code))
		values.Add("is_witness", fmt.Sprintf("%t", in.IsWitness))
		values.Add("is_committee", fmt.Sprintf("%t", in.IsCommittee))

		values.Add("asset_issued_name", base64.StdEncoding.EncodeToString(in.AssetIssuedName))
		values.Add("asset_issued_ID", base64.StdEncoding.EncodeToString(in.AssetIssued_ID))

		values.Add("free_net_usage", fmt.Sprintf("%d", in.FreeNetUsage))

		values.Add("latest_consume_time", fmt.Sprintf("%d", in.LatestConsumeTime))
		values.Add("latest_consume_free_time", fmt.Sprintf("%d", in.LatestConsumeFreeTime))
		values.Add("account_id", base64.StdEncoding.EncodeToString(in.AccountId))
		values.Add("net_window_size", fmt.Sprintf("%d", in.NetWindowSize))
		values.Add("net_window_optimized", fmt.Sprintf("%t", in.NetWindowOptimized))

		values.Add("codeHash", base64.StdEncoding.EncodeToString(in.CodeHash))

		values.Add("delegated_frozenV2_balance_for_bandwidth", fmt.Sprintf("%d", in.DelegatedFrozenV2BalanceForBandwidth))
		values.Add("acquired_delegated_frozenV2_balance_for_bandwidth", fmt.Sprintf("%d", in.AcquiredDelegatedFrozenV2BalanceForBandwidth))

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/getaccount"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetAccount_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_WalletSolidity_GetAccountById_0 = "/walletsolidity/getaccountbyid"

	pattern_goclay_WalletSolidity_GetAccountById_0_builder = func(in *core.Account) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/getaccountbyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetAccountById_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_WalletSolidity_GetAccountById_1 = "/walletsolidity/getaccountbyid"

	pattern_goclay_WalletSolidity_GetAccountById_1_builder = func(in *core.Account) string {
		values := url.Values{}
		values.Add("account_name", base64.StdEncoding.EncodeToString(in.AccountName))
		values.Add("type", fmt.Sprintf("%s", in.Type))
		values.Add("address", base64.StdEncoding.EncodeToString(in.Address))
		values.Add("balance", fmt.Sprintf("%d", in.Balance))

		values.Add("net_usage", fmt.Sprintf("%d", in.NetUsage))
		values.Add("acquired_delegated_frozen_balance_for_bandwidth", fmt.Sprintf("%d", in.AcquiredDelegatedFrozenBalanceForBandwidth))
		values.Add("delegated_frozen_balance_for_bandwidth", fmt.Sprintf("%d", in.DelegatedFrozenBalanceForBandwidth))
		values.Add("old_tron_power", fmt.Sprintf("%d", in.OldTronPower))

		values.Add("asset_optimized", fmt.Sprintf("%t", in.AssetOptimized))
		values.Add("create_time", fmt.Sprintf("%d", in.CreateTime))
		values.Add("latest_opration_time", fmt.Sprintf("%d", in.LatestOprationTime))
		values.Add("allowance", fmt.Sprintf("%d", in.Allowance))
		values.Add("latest_withdraw_time", fmt.Sprintf("%d", in.LatestWithdrawTime))
		values.Add("code", base64.StdEncoding.EncodeToString(in.Code))
		values.Add("is_witness", fmt.Sprintf("%t", in.IsWitness))
		values.Add("is_committee", fmt.Sprintf("%t", in.IsCommittee))

		values.Add("asset_issued_name", base64.StdEncoding.EncodeToString(in.AssetIssuedName))
		values.Add("asset_issued_ID", base64.StdEncoding.EncodeToString(in.AssetIssued_ID))

		values.Add("free_net_usage", fmt.Sprintf("%d", in.FreeNetUsage))

		values.Add("latest_consume_time", fmt.Sprintf("%d", in.LatestConsumeTime))
		values.Add("latest_consume_free_time", fmt.Sprintf("%d", in.LatestConsumeFreeTime))
		values.Add("account_id", base64.StdEncoding.EncodeToString(in.AccountId))
		values.Add("net_window_size", fmt.Sprintf("%d", in.NetWindowSize))
		values.Add("net_window_optimized", fmt.Sprintf("%t", in.NetWindowOptimized))

		values.Add("codeHash", base64.StdEncoding.EncodeToString(in.CodeHash))

		values.Add("delegated_frozenV2_balance_for_bandwidth", fmt.Sprintf("%d", in.DelegatedFrozenV2BalanceForBandwidth))
		values.Add("acquired_delegated_frozenV2_balance_for_bandwidth", fmt.Sprintf("%d", in.AcquiredDelegatedFrozenV2BalanceForBandwidth))

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/getaccountbyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetAccountById_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_WalletSolidity_ListWitnesses_0 = "/walletsolidity/listwitnesses"

	pattern_goclay_WalletSolidity_ListWitnesses_0_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/listwitnesses"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_ListWitnesses_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_WalletSolidity_ListWitnesses_1 = "/walletsolidity/listwitnesses"

	pattern_goclay_WalletSolidity_ListWitnesses_1_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/listwitnesses"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_ListWitnesses_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_WalletSolidity_GetAssetIssueList_0 = "/walletsolidity/getassetissuelist"

	pattern_goclay_WalletSolidity_GetAssetIssueList_0_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/getassetissuelist"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetAssetIssueList_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_WalletSolidity_GetAssetIssueList_1 = "/walletsolidity/getassetissuelist"

	pattern_goclay_WalletSolidity_GetAssetIssueList_1_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/getassetissuelist"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetAssetIssueList_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_WalletSolidity_GetPaginatedAssetIssueList_0 = "/walletsolidity/getpaginatedassetissuelist"

	pattern_goclay_WalletSolidity_GetPaginatedAssetIssueList_0_builder = func(in *PaginatedMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/getpaginatedassetissuelist"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetPaginatedAssetIssueList_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_WalletSolidity_GetPaginatedAssetIssueList_1 = "/walletsolidity/getpaginatedassetissuelist"

	pattern_goclay_WalletSolidity_GetPaginatedAssetIssueList_1_builder = func(in *PaginatedMessage) string {
		values := url.Values{}
		values.Add("offset", fmt.Sprintf("%d", in.Offset))
		values.Add("limit", fmt.Sprintf("%d", in.Limit))

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/getpaginatedassetissuelist"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetPaginatedAssetIssueList_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_WalletSolidity_GetNowBlock_0 = "/walletsolidity/getnowblock"

	pattern_goclay_WalletSolidity_GetNowBlock_0_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/getnowblock"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetNowBlock_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_WalletSolidity_GetNowBlock_1 = "/walletsolidity/getnowblock"

	pattern_goclay_WalletSolidity_GetNowBlock_1_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/getnowblock"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetNowBlock_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_WalletSolidity_GetBlockByNum_0 = "/walletsolidity/getblockbynum"

	pattern_goclay_WalletSolidity_GetBlockByNum_0_builder = func(in *NumberMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/getblockbynum"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetBlockByNum_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_WalletSolidity_GetBlockByNum_1 = "/walletsolidity/getblockbynum"

	pattern_goclay_WalletSolidity_GetBlockByNum_1_builder = func(in *NumberMessage) string {
		values := url.Values{}
		values.Add("num", fmt.Sprintf("%d", in.Num))

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/getblockbynum"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetBlockByNum_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_WalletSolidity_GetTransactionById_0 = "/walletsolidity/gettransactionbyid"

	pattern_goclay_WalletSolidity_GetTransactionById_0_builder = func(in *BytesMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/gettransactionbyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetTransactionById_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_WalletSolidity_GetTransactionById_1 = "/walletsolidity/gettransactionbyid"

	pattern_goclay_WalletSolidity_GetTransactionById_1_builder = func(in *BytesMessage) string {
		values := url.Values{}
		values.Add("value", base64.StdEncoding.EncodeToString(in.Value))

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/gettransactionbyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetTransactionById_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_WalletSolidity_GetTransactionInfoById_0 = "/walletsolidity/gettransactioninfobyid"

	pattern_goclay_WalletSolidity_GetTransactionInfoById_0_builder = func(in *BytesMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/gettransactioninfobyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetTransactionInfoById_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_WalletSolidity_GetTransactionInfoById_1 = "/walletsolidity/gettransactioninfobyid"

	pattern_goclay_WalletSolidity_GetTransactionInfoById_1_builder = func(in *BytesMessage) string {
		values := url.Values{}
		values.Add("value", base64.StdEncoding.EncodeToString(in.Value))

		u := url.URL{
			Path:     fmt.Sprintf("/walletsolidity/gettransactioninfobyid"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletSolidity_GetTransactionInfoById_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
)

// patterns for WalletExtension
var (
	pattern_goclay_WalletExtension_GetTransactionsFromThis_0 = "/walletextension/gettransactionsfromthis"

	pattern_goclay_WalletExtension_GetTransactionsFromThis_0_builder = func(in *AccountPaginated) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/walletextension/gettransactionsfromthis"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletExtension_GetTransactionsFromThis_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_WalletExtension_GetTransactionsFromThis_1 = "/walletextension/gettransactionsfromthis"

	pattern_goclay_WalletExtension_GetTransactionsFromThis_1_builder = func(in *AccountPaginated) string {
		values := url.Values{}

		values.Add("offset", fmt.Sprintf("%d", in.Offset))
		values.Add("limit", fmt.Sprintf("%d", in.Limit))

		u := url.URL{
			Path:     fmt.Sprintf("/walletextension/gettransactionsfromthis"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletExtension_GetTransactionsFromThis_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_WalletExtension_GetTransactionsToThis_0 = "/walletextension/gettransactionstothis"

	pattern_goclay_WalletExtension_GetTransactionsToThis_0_builder = func(in *AccountPaginated) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/walletextension/gettransactionstothis"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletExtension_GetTransactionsToThis_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_WalletExtension_GetTransactionsToThis_1 = "/walletextension/gettransactionstothis"

	pattern_goclay_WalletExtension_GetTransactionsToThis_1_builder = func(in *AccountPaginated) string {
		values := url.Values{}

		values.Add("offset", fmt.Sprintf("%d", in.Offset))
		values.Add("limit", fmt.Sprintf("%d", in.Limit))

		u := url.URL{
			Path:     fmt.Sprintf("/walletextension/gettransactionstothis"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_WalletExtension_GetTransactionsToThis_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
)

// patterns for Database
var ()

// patterns for Monitor
var (
	pattern_goclay_Monitor_GetStatsInfo_0 = "/monitor/getstatsinfo"

	pattern_goclay_Monitor_GetStatsInfo_0_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/monitor/getstatsinfo"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Monitor_GetStatsInfo_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_Monitor_GetStatsInfo_1 = "/monitor/getstatsinfo"

	pattern_goclay_Monitor_GetStatsInfo_1_builder = func(in *EmptyMessage) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/monitor/getstatsinfo"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_Monitor_GetStatsInfo_1_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
)

// marshalers for Wallet
var (
	unmarshaler_goclay_Wallet_GetAccount_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*core.Account)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetAccount_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetAccount_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*core.Account)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetAccount_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetAccountById_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*core.Account)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetAccountById_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetAccountById_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*core.Account)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetAccountById_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetAccountBalance_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.AccountBalanceRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetAccountBalance_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetAccountBalance_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.AccountBalanceRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetAccountBalance_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetBlockBalanceTrace_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.BlockBalanceTrace_BlockIdentifier)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetBlockBalanceTrace_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetBlockBalanceTrace_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.BlockBalanceTrace_BlockIdentifier)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetBlockBalanceTrace_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_CreateTransaction_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.TransferContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_CreateTransaction_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_CreateTransaction_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.TransferContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_CreateTransaction_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_BroadcastTransaction_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*core.Transaction)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_BroadcastTransaction_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_BroadcastTransaction_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*core.Transaction)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_BroadcastTransaction_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_UpdateAccount_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.AccountUpdateContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_UpdateAccount_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_UpdateAccount_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.AccountUpdateContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_UpdateAccount_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_SetAccountId_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.SetAccountIdContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_SetAccountId_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_SetAccountId_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.SetAccountIdContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_SetAccountId_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_VoteWitnessAccount_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.VoteWitnessContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_VoteWitnessAccount_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_VoteWitnessAccount_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.VoteWitnessContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_VoteWitnessAccount_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_CreateAssetIssue_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.AssetIssueContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_CreateAssetIssue_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_CreateAssetIssue_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.AssetIssueContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_CreateAssetIssue_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_UpdateWitness_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.WitnessUpdateContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_UpdateWitness_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_UpdateWitness_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.WitnessUpdateContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_UpdateWitness_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_CreateAccount_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.AccountCreateContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_CreateAccount_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_CreateAccount_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.AccountCreateContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_CreateAccount_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_CreateWitness_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.WitnessCreateContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_CreateWitness_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_CreateWitness_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.WitnessCreateContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_CreateWitness_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_TransferAsset_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.TransferAssetContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_TransferAsset_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_TransferAsset_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.TransferAssetContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_TransferAsset_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_ParticipateAssetIssue_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.ParticipateAssetIssueContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_ParticipateAssetIssue_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_ParticipateAssetIssue_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.ParticipateAssetIssueContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_ParticipateAssetIssue_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_FreezeBalance_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.FreezeBalanceContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_FreezeBalance_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_FreezeBalance_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.FreezeBalanceContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_FreezeBalance_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_UnfreezeBalance_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.UnfreezeBalanceContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_UnfreezeBalance_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_UnfreezeBalance_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.UnfreezeBalanceContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_UnfreezeBalance_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_UnfreezeAsset_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.UnfreezeAssetContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_UnfreezeAsset_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_UnfreezeAsset_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.UnfreezeAssetContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_UnfreezeAsset_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_WithdrawBalance_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.WithdrawBalanceContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_WithdrawBalance_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_WithdrawBalance_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.WithdrawBalanceContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_WithdrawBalance_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_UpdateAsset_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.UpdateAssetContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_UpdateAsset_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_UpdateAsset_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.UpdateAssetContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_UpdateAsset_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_ListNodes_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_ListNodes_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_ListNodes_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_ListNodes_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetAssetIssueByAccount_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*core.Account)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetAssetIssueByAccount_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetAssetIssueByAccount_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*core.Account)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetAssetIssueByAccount_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetAccountNet_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*core.Account)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetAccountNet_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetAccountNet_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*core.Account)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetAccountNet_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetAssetIssueByName_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetAssetIssueByName_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetAssetIssueByName_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetAssetIssueByName_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetNowBlock_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetNowBlock_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetNowBlock_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetNowBlock_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetBlockByNum_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*NumberMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetBlockByNum_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetBlockByNum_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*NumberMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetBlockByNum_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetBlockById_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetBlockById_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetBlockById_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetBlockById_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetBlockByLimitNext_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BlockLimit)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetBlockByLimitNext_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetBlockByLimitNext_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BlockLimit)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetBlockByLimitNext_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetBlockByLatestNum_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*NumberMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetBlockByLatestNum_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetBlockByLatestNum_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*NumberMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetBlockByLatestNum_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetTransactionById_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetTransactionById_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetTransactionById_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetTransactionById_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_ListWitnesses_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_ListWitnesses_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_ListWitnesses_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_ListWitnesses_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_ListProposals_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_ListProposals_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_ListProposals_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_ListProposals_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetPaginatedProposalList_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*PaginatedMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetPaginatedProposalList_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetPaginatedProposalList_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*PaginatedMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetPaginatedProposalList_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetProposalById_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetProposalById_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetProposalById_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetProposalById_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_ListExchanges_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_ListExchanges_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_ListExchanges_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_ListExchanges_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetPaginatedExchangeList_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*PaginatedMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetPaginatedExchangeList_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetPaginatedExchangeList_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*PaginatedMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetPaginatedExchangeList_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetExchangeById_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetExchangeById_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetExchangeById_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetExchangeById_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetChainParameters_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetChainParameters_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetChainParameters_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetChainParameters_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetAssetIssueList_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetAssetIssueList_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetAssetIssueList_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetAssetIssueList_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetPaginatedAssetIssueList_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*PaginatedMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetPaginatedAssetIssueList_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetPaginatedAssetIssueList_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*PaginatedMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetPaginatedAssetIssueList_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_TotalTransaction_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_TotalTransaction_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_TotalTransaction_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_TotalTransaction_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetNextMaintenanceTime_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetNextMaintenanceTime_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetNextMaintenanceTime_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetNextMaintenanceTime_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetTransactionInfoById_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetTransactionInfoById_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_GetTransactionInfoById_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_GetTransactionInfoById_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_Wallet_AccountPermissionUpdate_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.AccountPermissionUpdateContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_AccountPermissionUpdate_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Wallet_AccountPermissionUpdate_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*contract.AccountPermissionUpdateContract)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Wallet_AccountPermissionUpdate_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}
)

// marshalers for WalletSolidity
var (
	unmarshaler_goclay_WalletSolidity_GetAccount_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*core.Account)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetAccount_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_GetAccount_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*core.Account)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetAccount_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_GetAccountById_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*core.Account)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetAccountById_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_GetAccountById_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*core.Account)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetAccountById_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_ListWitnesses_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_ListWitnesses_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_ListWitnesses_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_ListWitnesses_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_GetAssetIssueList_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetAssetIssueList_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_GetAssetIssueList_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetAssetIssueList_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_GetPaginatedAssetIssueList_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*PaginatedMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetPaginatedAssetIssueList_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_GetPaginatedAssetIssueList_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*PaginatedMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetPaginatedAssetIssueList_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_GetNowBlock_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetNowBlock_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_GetNowBlock_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetNowBlock_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_GetBlockByNum_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*NumberMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetBlockByNum_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_GetBlockByNum_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*NumberMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetBlockByNum_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_GetTransactionById_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetTransactionById_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_GetTransactionById_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetTransactionById_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_GetTransactionInfoById_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetTransactionInfoById_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_WalletSolidity_GetTransactionInfoById_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*BytesMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletSolidity_GetTransactionInfoById_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}
)

// marshalers for WalletExtension
var (
	unmarshaler_goclay_WalletExtension_GetTransactionsFromThis_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*AccountPaginated)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletExtension_GetTransactionsFromThis_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_WalletExtension_GetTransactionsFromThis_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*AccountPaginated)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletExtension_GetTransactionsFromThis_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_WalletExtension_GetTransactionsToThis_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*AccountPaginated)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletExtension_GetTransactionsToThis_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_WalletExtension_GetTransactionsToThis_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*AccountPaginated)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_WalletExtension_GetTransactionsToThis_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}
)

// marshalers for Database
var ()

// marshalers for Monitor
var (
	unmarshaler_goclay_Monitor_GetStatsInfo_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Monitor_GetStatsInfo_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}
			return nil
		}
	}

	unmarshaler_goclay_Monitor_GetStatsInfo_1 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*EmptyMessage)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_Monitor_GetStatsInfo_1_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}
)

var _swaggerDef_api_api_proto = []byte(`{
  "swagger": "2.0",
  "info": {
    "title": "api/api.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "Wallet"
    },
    {
      "name": "WalletSolidity"
    },
    {
      "name": "WalletExtension"
    },
    {
      "name": "Database"
    },
    {
      "name": "Monitor"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/monitor/getstatsinfo": {
      "get": {
        "operationId": "Monitor_GetStatsInfo2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolMetricsInfo"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "post": {
        "operationId": "Monitor_GetStatsInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolMetricsInfo"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolEmptyMessage"
            }
          }
        ],
        "tags": [
          "Monitor"
        ]
      }
    },
    "/wallet/accountpermissionupdate": {
      "get": {
        "operationId": "Wallet_AccountPermissionUpdate2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransactionExtention"
            }
          }
        },
        "parameters": [
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "owner.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "owner.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "owner.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "owner.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "owner.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "owner.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "witness.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "witness.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "witness.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "witness.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "witness.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "witness.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_AccountPermissionUpdate",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransactionExtention"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolAccountPermissionUpdateContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/broadcasttransaction": {
      "get": {
        "operationId": "Wallet_BroadcastTransaction2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolReturn"
            }
          }
        },
        "parameters": [
          {
            "name": "rawData.refBlockBytes",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "rawData.refBlockNum",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "rawData.refBlockHash",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "rawData.expiration",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "rawData.data",
            "description": "data not used.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "rawData.scripts",
            "description": "scripts not used.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "rawData.timestamp",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "rawData.feeLimit",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "signature",
            "description": "only support size = 1,  repeated list here for muti-sig extension.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string",
              "format": "byte"
            },
            "collectionFormat": "multi"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_BroadcastTransaction",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolReturn"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/createaccount": {
      "get": {
        "summary": "Please use CreateAccount2 instead of this function.",
        "operationId": "Wallet_CreateAccount2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "accountAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Normal",
              "AssetIssue",
              "Contract"
            ],
            "default": "Normal"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use CreateAccount2 instead of this function.",
        "operationId": "Wallet_CreateAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolAccountCreateContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/createassetissue": {
      "get": {
        "summary": "Please use CreateAssetIssue2 instead of this function.",
        "operationId": "Wallet_CreateAssetIssue2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "name",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "abbr",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "totalSupply",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "trxNum",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "precision",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "num",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "startTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "endTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "order",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "voteScore",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "description",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "url",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "freeAssetNetLimit",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "publicFreeAssetNetLimit",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "publicFreeAssetNetUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "publicLatestFreeNetTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use CreateAssetIssue2 instead of this function.",
        "operationId": "Wallet_CreateAssetIssue",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolAssetIssueContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/createtransaction": {
      "get": {
        "summary": "Please use CreateTransaction2 instead of this function.",
        "operationId": "Wallet_CreateTransaction2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "toAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "amount",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use CreateTransaction2 instead of this function.",
        "operationId": "Wallet_CreateTransaction",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolTransferContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/createwitness": {
      "get": {
        "summary": "Please use CreateWitness2 instead of this function.",
        "operationId": "Wallet_CreateWitness2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "url",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use CreateWitness2 instead of this function.",
        "operationId": "Wallet_CreateWitness",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolWitnessCreateContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/freezebalance": {
      "get": {
        "summary": "Please use FreezeBalance2 instead of this function.",
        "operationId": "Wallet_FreezeBalance2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "frozenDuration",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "resource",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "BANDWIDTH",
              "ENERGY",
              "TRON_POWER"
            ],
            "default": "BANDWIDTH"
          },
          {
            "name": "receiverAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use FreezeBalance2 instead of this function.",
        "operationId": "Wallet_FreezeBalance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolFreezeBalanceContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getaccount": {
      "get": {
        "operationId": "Wallet_GetAccount2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAccount"
            }
          }
        },
        "parameters": [
          {
            "name": "accountName",
            "description": "account nick name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Normal",
              "AssetIssue",
              "Contract"
            ],
            "default": "Normal"
          },
          {
            "name": "address",
            "description": "the create address.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "balance",
            "description": "the trx balance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "netUsage",
            "description": "bandwidth, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "acquiredDelegatedFrozenBalanceForBandwidth",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "delegatedFrozenBalanceForBandwidth",
            "description": "Freeze and provide balances to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "oldTronPower",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "tronPower.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "tronPower.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "assetOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "createTime",
            "description": "this account create time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestOprationTime",
            "description": "this last operation time, including transfer, voting and so on. //FIXME fix grammar.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "allowance",
            "description": "witness block producing allowance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestWithdrawTime",
            "description": "last withdraw time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "code",
            "description": "not used so far.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "isWitness",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "isCommittee",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "assetIssuedName",
            "description": "asset_issued_name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "assetIssuedID",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "freeNetUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestConsumeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestConsumeFreeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountId",
            "description": "the identity of this account, case insensitive.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "netWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "netWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "accountResource.energyUsage",
            "description": "energy resource, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.frozenBalanceForEnergy.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.frozenBalanceForEnergy.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.latestConsumeTimeForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.acquiredDelegatedFrozenBalanceForEnergy",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.delegatedFrozenBalanceForEnergy",
            "description": "Frozen balances provided to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.storageLimit",
            "description": "storage resource, get from market.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.storageUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.latestExchangeStorageTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.energyWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.delegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.acquiredDelegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.energyWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "codeHash",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "ownerPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "ownerPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "ownerPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "ownerPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "ownerPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "ownerPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "witnessPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "witnessPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "witnessPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "witnessPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "witnessPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "witnessPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "delegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "acquiredDelegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAccount"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolAccount"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getaccountbalance": {
      "get": {
        "operationId": "Wallet_GetAccountBalance2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAccountBalanceResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "accountIdentifier.address",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "blockIdentifier.hash",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "blockIdentifier.number",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetAccountBalance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAccountBalanceResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolAccountBalanceRequest"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getaccountbyid": {
      "get": {
        "operationId": "Wallet_GetAccountById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAccount"
            }
          }
        },
        "parameters": [
          {
            "name": "accountName",
            "description": "account nick name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Normal",
              "AssetIssue",
              "Contract"
            ],
            "default": "Normal"
          },
          {
            "name": "address",
            "description": "the create address.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "balance",
            "description": "the trx balance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "netUsage",
            "description": "bandwidth, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "acquiredDelegatedFrozenBalanceForBandwidth",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "delegatedFrozenBalanceForBandwidth",
            "description": "Freeze and provide balances to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "oldTronPower",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "tronPower.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "tronPower.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "assetOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "createTime",
            "description": "this account create time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestOprationTime",
            "description": "this last operation time, including transfer, voting and so on. //FIXME fix grammar.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "allowance",
            "description": "witness block producing allowance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestWithdrawTime",
            "description": "last withdraw time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "code",
            "description": "not used so far.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "isWitness",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "isCommittee",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "assetIssuedName",
            "description": "asset_issued_name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "assetIssuedID",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "freeNetUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestConsumeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestConsumeFreeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountId",
            "description": "the identity of this account, case insensitive.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "netWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "netWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "accountResource.energyUsage",
            "description": "energy resource, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.frozenBalanceForEnergy.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.frozenBalanceForEnergy.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.latestConsumeTimeForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.acquiredDelegatedFrozenBalanceForEnergy",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.delegatedFrozenBalanceForEnergy",
            "description": "Frozen balances provided to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.storageLimit",
            "description": "storage resource, get from market.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.storageUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.latestExchangeStorageTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.energyWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.delegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.acquiredDelegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.energyWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "codeHash",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "ownerPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "ownerPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "ownerPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "ownerPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "ownerPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "ownerPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "witnessPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "witnessPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "witnessPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "witnessPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "witnessPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "witnessPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "delegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "acquiredDelegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetAccountById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAccount"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolAccount"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getaccountnet": {
      "get": {
        "operationId": "Wallet_GetAccountNet2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAccountNetMessage"
            }
          }
        },
        "parameters": [
          {
            "name": "accountName",
            "description": "account nick name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Normal",
              "AssetIssue",
              "Contract"
            ],
            "default": "Normal"
          },
          {
            "name": "address",
            "description": "the create address.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "balance",
            "description": "the trx balance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "netUsage",
            "description": "bandwidth, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "acquiredDelegatedFrozenBalanceForBandwidth",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "delegatedFrozenBalanceForBandwidth",
            "description": "Freeze and provide balances to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "oldTronPower",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "tronPower.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "tronPower.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "assetOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "createTime",
            "description": "this account create time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestOprationTime",
            "description": "this last operation time, including transfer, voting and so on. //FIXME fix grammar.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "allowance",
            "description": "witness block producing allowance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestWithdrawTime",
            "description": "last withdraw time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "code",
            "description": "not used so far.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "isWitness",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "isCommittee",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "assetIssuedName",
            "description": "asset_issued_name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "assetIssuedID",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "freeNetUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestConsumeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestConsumeFreeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountId",
            "description": "the identity of this account, case insensitive.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "netWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "netWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "accountResource.energyUsage",
            "description": "energy resource, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.frozenBalanceForEnergy.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.frozenBalanceForEnergy.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.latestConsumeTimeForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.acquiredDelegatedFrozenBalanceForEnergy",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.delegatedFrozenBalanceForEnergy",
            "description": "Frozen balances provided to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.storageLimit",
            "description": "storage resource, get from market.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.storageUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.latestExchangeStorageTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.energyWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.delegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.acquiredDelegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.energyWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "codeHash",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "ownerPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "ownerPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "ownerPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "ownerPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "ownerPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "ownerPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "witnessPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "witnessPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "witnessPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "witnessPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "witnessPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "witnessPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "delegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "acquiredDelegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetAccountNet",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAccountNetMessage"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolAccount"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getassetissuebyaccount": {
      "get": {
        "operationId": "Wallet_GetAssetIssueByAccount2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAssetIssueList"
            }
          }
        },
        "parameters": [
          {
            "name": "accountName",
            "description": "account nick name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Normal",
              "AssetIssue",
              "Contract"
            ],
            "default": "Normal"
          },
          {
            "name": "address",
            "description": "the create address.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "balance",
            "description": "the trx balance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "netUsage",
            "description": "bandwidth, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "acquiredDelegatedFrozenBalanceForBandwidth",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "delegatedFrozenBalanceForBandwidth",
            "description": "Freeze and provide balances to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "oldTronPower",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "tronPower.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "tronPower.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "assetOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "createTime",
            "description": "this account create time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestOprationTime",
            "description": "this last operation time, including transfer, voting and so on. //FIXME fix grammar.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "allowance",
            "description": "witness block producing allowance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestWithdrawTime",
            "description": "last withdraw time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "code",
            "description": "not used so far.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "isWitness",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "isCommittee",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "assetIssuedName",
            "description": "asset_issued_name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "assetIssuedID",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "freeNetUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestConsumeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestConsumeFreeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountId",
            "description": "the identity of this account, case insensitive.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "netWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "netWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "accountResource.energyUsage",
            "description": "energy resource, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.frozenBalanceForEnergy.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.frozenBalanceForEnergy.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.latestConsumeTimeForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.acquiredDelegatedFrozenBalanceForEnergy",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.delegatedFrozenBalanceForEnergy",
            "description": "Frozen balances provided to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.storageLimit",
            "description": "storage resource, get from market.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.storageUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.latestExchangeStorageTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.energyWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.delegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.acquiredDelegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.energyWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "codeHash",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "ownerPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "ownerPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "ownerPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "ownerPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "ownerPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "ownerPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "witnessPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "witnessPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "witnessPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "witnessPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "witnessPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "witnessPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "delegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "acquiredDelegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetAssetIssueByAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAssetIssueList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolAccount"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getassetissuebyname": {
      "get": {
        "operationId": "Wallet_GetAssetIssueByName2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAssetIssueContract"
            }
          }
        },
        "parameters": [
          {
            "name": "value",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetAssetIssueByName",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAssetIssueContract"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolBytesMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getassetissuelist": {
      "get": {
        "operationId": "Wallet_GetAssetIssueList2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAssetIssueList"
            }
          }
        },
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetAssetIssueList",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAssetIssueList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolEmptyMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getblockbalancetrace": {
      "get": {
        "operationId": "Wallet_GetBlockBalanceTrace2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlockBalanceTrace"
            }
          }
        },
        "parameters": [
          {
            "name": "hash",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "number",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetBlockBalanceTrace",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlockBalanceTrace"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/BlockBalanceTraceBlockIdentifier"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getblockbyid": {
      "get": {
        "operationId": "Wallet_GetBlockById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlock"
            }
          }
        },
        "parameters": [
          {
            "name": "value",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetBlockById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlock"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolBytesMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getblockbylatestnum": {
      "get": {
        "summary": "Please use GetBlockByLatestNum2 instead of this function.",
        "operationId": "Wallet_GetBlockByLatestNum2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlockList"
            }
          }
        },
        "parameters": [
          {
            "name": "num",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use GetBlockByLatestNum2 instead of this function.",
        "operationId": "Wallet_GetBlockByLatestNum",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlockList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolNumberMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getblockbylimitnext": {
      "get": {
        "summary": "Please use GetBlockByLimitNext2 instead of this function.",
        "operationId": "Wallet_GetBlockByLimitNext2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlockList"
            }
          }
        },
        "parameters": [
          {
            "name": "startNum",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "endNum",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use GetBlockByLimitNext2 instead of this function.",
        "operationId": "Wallet_GetBlockByLimitNext",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlockList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolBlockLimit"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getblockbynum": {
      "get": {
        "summary": "Please use GetBlockByNum2 instead of this function.",
        "operationId": "Wallet_GetBlockByNum2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlock"
            }
          }
        },
        "parameters": [
          {
            "name": "num",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use GetBlockByNum2 instead of this function.",
        "operationId": "Wallet_GetBlockByNum",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlock"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolNumberMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getchainparameters": {
      "get": {
        "operationId": "Wallet_GetChainParameters2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolChainParameters"
            }
          }
        },
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetChainParameters",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolChainParameters"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolEmptyMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getexchangebyid": {
      "get": {
        "operationId": "Wallet_GetExchangeById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolExchange"
            }
          }
        },
        "parameters": [
          {
            "name": "value",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetExchangeById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolExchange"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolBytesMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getnextmaintenancetime": {
      "get": {
        "operationId": "Wallet_GetNextMaintenanceTime2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolNumberMessage"
            }
          }
        },
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetNextMaintenanceTime",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolNumberMessage"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolEmptyMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getnowblock": {
      "get": {
        "summary": "Please use GetNowBlock2 instead of this function.",
        "operationId": "Wallet_GetNowBlock2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlock"
            }
          }
        },
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use GetNowBlock2 instead of this function.",
        "operationId": "Wallet_GetNowBlock",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlock"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolEmptyMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getpaginatedassetissuelist": {
      "get": {
        "operationId": "Wallet_GetPaginatedAssetIssueList2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAssetIssueList"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetPaginatedAssetIssueList",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAssetIssueList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolPaginatedMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getpaginatedexchangelist": {
      "get": {
        "operationId": "Wallet_GetPaginatedExchangeList2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolExchangeList"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetPaginatedExchangeList",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolExchangeList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolPaginatedMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getpaginatedproposallist": {
      "get": {
        "operationId": "Wallet_GetPaginatedProposalList2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolProposalList"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetPaginatedProposalList",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolProposalList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolPaginatedMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/getproposalbyid": {
      "get": {
        "operationId": "Wallet_GetProposalById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolProposal"
            }
          }
        },
        "parameters": [
          {
            "name": "value",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetProposalById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolProposal"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolBytesMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/gettransactionbyid": {
      "get": {
        "operationId": "Wallet_GetTransactionById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "value",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetTransactionById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolBytesMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/gettransactioninfobyid": {
      "get": {
        "operationId": "Wallet_GetTransactionInfoById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransactionInfo"
            }
          }
        },
        "parameters": [
          {
            "name": "value",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_GetTransactionInfoById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransactionInfo"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolBytesMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/listexchanges": {
      "get": {
        "operationId": "Wallet_ListExchanges2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolExchangeList"
            }
          }
        },
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_ListExchanges",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolExchangeList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolEmptyMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/listnodes": {
      "get": {
        "operationId": "Wallet_ListNodes2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolNodeList"
            }
          }
        },
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_ListNodes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolNodeList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolEmptyMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/listproposals": {
      "get": {
        "operationId": "Wallet_ListProposals2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolProposalList"
            }
          }
        },
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_ListProposals",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolProposalList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolEmptyMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/listwitnesses": {
      "get": {
        "operationId": "Wallet_ListWitnesses2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolWitnessList"
            }
          }
        },
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_ListWitnesses",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolWitnessList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolEmptyMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/participateassetissue": {
      "get": {
        "summary": "Please use ParticipateAssetIssue2 instead of this function.",
        "operationId": "Wallet_ParticipateAssetIssue2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "toAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "assetName",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "amount",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use ParticipateAssetIssue2 instead of this function.",
        "operationId": "Wallet_ParticipateAssetIssue",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolParticipateAssetIssueContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/setaccountid": {
      "get": {
        "operationId": "Wallet_SetAccountId2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "accountId",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_SetAccountId",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolSetAccountIdContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/totaltransaction": {
      "get": {
        "operationId": "Wallet_TotalTransaction2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolNumberMessage"
            }
          }
        },
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "operationId": "Wallet_TotalTransaction",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolNumberMessage"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolEmptyMessage"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/transferasset": {
      "get": {
        "summary": "Please use TransferAsset2 instead of this function.",
        "operationId": "Wallet_TransferAsset2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "assetName",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "toAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "amount",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use TransferAsset2 instead of this function.",
        "operationId": "Wallet_TransferAsset",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolTransferAssetContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/unfreezeasset": {
      "get": {
        "summary": "Please use UnfreezeAsset2 instead of this function.",
        "operationId": "Wallet_UnfreezeAsset2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use UnfreezeAsset2 instead of this function.",
        "operationId": "Wallet_UnfreezeAsset",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolUnfreezeAssetContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/unfreezebalance": {
      "get": {
        "summary": "Please use UnfreezeBalance2 instead of this function.",
        "operationId": "Wallet_UnfreezeBalance2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "resource",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "BANDWIDTH",
              "ENERGY",
              "TRON_POWER"
            ],
            "default": "BANDWIDTH"
          },
          {
            "name": "receiverAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use UnfreezeBalance2 instead of this function.",
        "operationId": "Wallet_UnfreezeBalance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolUnfreezeBalanceContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/updateaccount": {
      "get": {
        "summary": "Please use UpdateAccount2 instead of this function.",
        "operationId": "Wallet_UpdateAccount2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "accountName",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use UpdateAccount2 instead of this function.",
        "operationId": "Wallet_UpdateAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolAccountUpdateContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/updateasset": {
      "get": {
        "summary": "Please use UpdateAsset2 instead of this function.",
        "operationId": "Wallet_UpdateAsset2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "description",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "url",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "newLimit",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "newPublicLimit",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use UpdateAsset2 instead of this function.",
        "operationId": "Wallet_UpdateAsset",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolUpdateAssetContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/updatewitness": {
      "get": {
        "summary": "Please use UpdateWitness2 instead of this function.",
        "operationId": "Wallet_UpdateWitness2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "updateUrl",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use UpdateWitness2 instead of this function.",
        "operationId": "Wallet_UpdateWitness",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolWitnessUpdateContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/votewitnessaccount": {
      "get": {
        "summary": "Please use VoteWitnessAccount2 instead of this function.",
        "operationId": "Wallet_VoteWitnessAccount2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "support",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use VoteWitnessAccount2 instead of this function.",
        "operationId": "Wallet_VoteWitnessAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolVoteWitnessContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/wallet/withdrawbalance": {
      "get": {
        "summary": "Please use WithdrawBalance2 instead of this function.",
        "operationId": "Wallet_WithdrawBalance2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "ownerAddress",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Wallet"
        ]
      },
      "post": {
        "summary": "Please use WithdrawBalance2 instead of this function.",
        "operationId": "Wallet_WithdrawBalance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolWithdrawBalanceContract"
            }
          }
        ],
        "tags": [
          "Wallet"
        ]
      }
    },
    "/walletextension/gettransactionsfromthis": {
      "get": {
        "summary": "Please use GetTransactionsFromThis2 instead of this function.",
        "operationId": "WalletExtension_GetTransactionsFromThis2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransactionList"
            }
          }
        },
        "parameters": [
          {
            "name": "account.accountName",
            "description": "account nick name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Normal",
              "AssetIssue",
              "Contract"
            ],
            "default": "Normal"
          },
          {
            "name": "account.address",
            "description": "the create address.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.balance",
            "description": "the trx balance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.netUsage",
            "description": "bandwidth, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.acquiredDelegatedFrozenBalanceForBandwidth",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.delegatedFrozenBalanceForBandwidth",
            "description": "Freeze and provide balances to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.oldTronPower",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.tronPower.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.tronPower.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.assetOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "account.createTime",
            "description": "this account create time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.latestOprationTime",
            "description": "this last operation time, including transfer, voting and so on. //FIXME fix grammar.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.allowance",
            "description": "witness block producing allowance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.latestWithdrawTime",
            "description": "last withdraw time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.code",
            "description": "not used so far.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.isWitness",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "account.isCommittee",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "account.assetIssuedName",
            "description": "asset_issued_name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.assetIssuedID",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.freeNetUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.latestConsumeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.latestConsumeFreeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountId",
            "description": "the identity of this account, case insensitive.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.netWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.netWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "account.accountResource.energyUsage",
            "description": "energy resource, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.frozenBalanceForEnergy.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.frozenBalanceForEnergy.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.latestConsumeTimeForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.acquiredDelegatedFrozenBalanceForEnergy",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.delegatedFrozenBalanceForEnergy",
            "description": "Frozen balances provided to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.storageLimit",
            "description": "storage resource, get from market.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.storageUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.latestExchangeStorageTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.energyWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.delegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.acquiredDelegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.energyWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "account.codeHash",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.ownerPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "account.ownerPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "account.ownerPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "account.ownerPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.ownerPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "account.ownerPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.witnessPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "account.witnessPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "account.witnessPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "account.witnessPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.witnessPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "account.witnessPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.delegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.acquiredDelegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "WalletExtension"
        ]
      },
      "post": {
        "summary": "Please use GetTransactionsFromThis2 instead of this function.",
        "operationId": "WalletExtension_GetTransactionsFromThis",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransactionList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolAccountPaginated"
            }
          }
        ],
        "tags": [
          "WalletExtension"
        ]
      }
    },
    "/walletextension/gettransactionstothis": {
      "get": {
        "summary": "Please use GetTransactionsToThis2 instead of this function.",
        "operationId": "WalletExtension_GetTransactionsToThis2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransactionList"
            }
          }
        },
        "parameters": [
          {
            "name": "account.accountName",
            "description": "account nick name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Normal",
              "AssetIssue",
              "Contract"
            ],
            "default": "Normal"
          },
          {
            "name": "account.address",
            "description": "the create address.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.balance",
            "description": "the trx balance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.netUsage",
            "description": "bandwidth, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.acquiredDelegatedFrozenBalanceForBandwidth",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.delegatedFrozenBalanceForBandwidth",
            "description": "Freeze and provide balances to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.oldTronPower",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.tronPower.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.tronPower.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.assetOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "account.createTime",
            "description": "this account create time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.latestOprationTime",
            "description": "this last operation time, including transfer, voting and so on. //FIXME fix grammar.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.allowance",
            "description": "witness block producing allowance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.latestWithdrawTime",
            "description": "last withdraw time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.code",
            "description": "not used so far.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.isWitness",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "account.isCommittee",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "account.assetIssuedName",
            "description": "asset_issued_name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.assetIssuedID",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.freeNetUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.latestConsumeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.latestConsumeFreeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountId",
            "description": "the identity of this account, case insensitive.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.netWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.netWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "account.accountResource.energyUsage",
            "description": "energy resource, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.frozenBalanceForEnergy.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.frozenBalanceForEnergy.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.latestConsumeTimeForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.acquiredDelegatedFrozenBalanceForEnergy",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.delegatedFrozenBalanceForEnergy",
            "description": "Frozen balances provided to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.storageLimit",
            "description": "storage resource, get from market.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.storageUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.latestExchangeStorageTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.energyWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.delegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.acquiredDelegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.accountResource.energyWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "account.codeHash",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.ownerPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "account.ownerPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "account.ownerPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "account.ownerPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.ownerPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "account.ownerPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.witnessPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "account.witnessPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "account.witnessPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "account.witnessPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.witnessPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "account.witnessPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "account.delegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account.acquiredDelegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "WalletExtension"
        ]
      },
      "post": {
        "summary": "Please use GetTransactionsToThis2 instead of this function.",
        "operationId": "WalletExtension_GetTransactionsToThis",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransactionList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolAccountPaginated"
            }
          }
        ],
        "tags": [
          "WalletExtension"
        ]
      }
    },
    "/walletsolidity/getaccount": {
      "get": {
        "operationId": "WalletSolidity_GetAccount2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAccount"
            }
          }
        },
        "parameters": [
          {
            "name": "accountName",
            "description": "account nick name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Normal",
              "AssetIssue",
              "Contract"
            ],
            "default": "Normal"
          },
          {
            "name": "address",
            "description": "the create address.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "balance",
            "description": "the trx balance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "netUsage",
            "description": "bandwidth, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "acquiredDelegatedFrozenBalanceForBandwidth",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "delegatedFrozenBalanceForBandwidth",
            "description": "Freeze and provide balances to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "oldTronPower",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "tronPower.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "tronPower.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "assetOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "createTime",
            "description": "this account create time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestOprationTime",
            "description": "this last operation time, including transfer, voting and so on. //FIXME fix grammar.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "allowance",
            "description": "witness block producing allowance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestWithdrawTime",
            "description": "last withdraw time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "code",
            "description": "not used so far.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "isWitness",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "isCommittee",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "assetIssuedName",
            "description": "asset_issued_name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "assetIssuedID",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "freeNetUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestConsumeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestConsumeFreeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountId",
            "description": "the identity of this account, case insensitive.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "netWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "netWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "accountResource.energyUsage",
            "description": "energy resource, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.frozenBalanceForEnergy.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.frozenBalanceForEnergy.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.latestConsumeTimeForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.acquiredDelegatedFrozenBalanceForEnergy",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.delegatedFrozenBalanceForEnergy",
            "description": "Frozen balances provided to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.storageLimit",
            "description": "storage resource, get from market.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.storageUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.latestExchangeStorageTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.energyWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.delegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.acquiredDelegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.energyWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "codeHash",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "ownerPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "ownerPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "ownerPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "ownerPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "ownerPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "ownerPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "witnessPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "witnessPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "witnessPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "witnessPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "witnessPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "witnessPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "delegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "acquiredDelegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "WalletSolidity"
        ]
      },
      "post": {
        "operationId": "WalletSolidity_GetAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAccount"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolAccount"
            }
          }
        ],
        "tags": [
          "WalletSolidity"
        ]
      }
    },
    "/walletsolidity/getaccountbyid": {
      "get": {
        "operationId": "WalletSolidity_GetAccountById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAccount"
            }
          }
        },
        "parameters": [
          {
            "name": "accountName",
            "description": "account nick name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Normal",
              "AssetIssue",
              "Contract"
            ],
            "default": "Normal"
          },
          {
            "name": "address",
            "description": "the create address.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "balance",
            "description": "the trx balance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "netUsage",
            "description": "bandwidth, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "acquiredDelegatedFrozenBalanceForBandwidth",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "delegatedFrozenBalanceForBandwidth",
            "description": "Freeze and provide balances to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "oldTronPower",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "tronPower.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "tronPower.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "assetOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "createTime",
            "description": "this account create time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestOprationTime",
            "description": "this last operation time, including transfer, voting and so on. //FIXME fix grammar.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "allowance",
            "description": "witness block producing allowance.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestWithdrawTime",
            "description": "last withdraw time.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "code",
            "description": "not used so far.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "isWitness",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "isCommittee",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "assetIssuedName",
            "description": "asset_issued_name.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "assetIssuedID",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "freeNetUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestConsumeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "latestConsumeFreeTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountId",
            "description": "the identity of this account, case insensitive.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "netWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "netWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "accountResource.energyUsage",
            "description": "energy resource, get from frozen.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.frozenBalanceForEnergy.frozenBalance",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.frozenBalanceForEnergy.expireTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.latestConsumeTimeForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.acquiredDelegatedFrozenBalanceForEnergy",
            "description": "Frozen balance provided by other accounts to this account.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.delegatedFrozenBalanceForEnergy",
            "description": "Frozen balances provided to other accounts.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.storageLimit",
            "description": "storage resource, get from market.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.storageUsage",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.latestExchangeStorageTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.energyWindowSize",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.delegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.acquiredDelegatedFrozenV2BalanceForEnergy",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "accountResource.energyWindowOptimized",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "codeHash",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "ownerPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "ownerPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "ownerPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "ownerPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "ownerPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "ownerPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "witnessPermission.type",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "Owner",
              "Witness",
              "Active"
            ],
            "default": "Owner"
          },
          {
            "name": "witnessPermission.id",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "witnessPermission.permissionName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "witnessPermission.threshold",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "witnessPermission.parentId",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "witnessPermission.operations",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "delegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "acquiredDelegatedFrozenV2BalanceForBandwidth",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "WalletSolidity"
        ]
      },
      "post": {
        "operationId": "WalletSolidity_GetAccountById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAccount"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolAccount"
            }
          }
        ],
        "tags": [
          "WalletSolidity"
        ]
      }
    },
    "/walletsolidity/getassetissuelist": {
      "get": {
        "operationId": "WalletSolidity_GetAssetIssueList2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAssetIssueList"
            }
          }
        },
        "tags": [
          "WalletSolidity"
        ]
      },
      "post": {
        "operationId": "WalletSolidity_GetAssetIssueList",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAssetIssueList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolEmptyMessage"
            }
          }
        ],
        "tags": [
          "WalletSolidity"
        ]
      }
    },
    "/walletsolidity/getblockbynum": {
      "get": {
        "summary": "Please use GetBlockByNum2 instead of this function.",
        "operationId": "WalletSolidity_GetBlockByNum2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlock"
            }
          }
        },
        "parameters": [
          {
            "name": "num",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "WalletSolidity"
        ]
      },
      "post": {
        "summary": "Please use GetBlockByNum2 instead of this function.",
        "operationId": "WalletSolidity_GetBlockByNum",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlock"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolNumberMessage"
            }
          }
        ],
        "tags": [
          "WalletSolidity"
        ]
      }
    },
    "/walletsolidity/getnowblock": {
      "get": {
        "summary": "Please use GetNowBlock2 instead of this function.",
        "operationId": "WalletSolidity_GetNowBlock2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlock"
            }
          }
        },
        "tags": [
          "WalletSolidity"
        ]
      },
      "post": {
        "summary": "Please use GetNowBlock2 instead of this function.",
        "operationId": "WalletSolidity_GetNowBlock",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolBlock"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolEmptyMessage"
            }
          }
        ],
        "tags": [
          "WalletSolidity"
        ]
      }
    },
    "/walletsolidity/getpaginatedassetissuelist": {
      "get": {
        "operationId": "WalletSolidity_GetPaginatedAssetIssueList2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAssetIssueList"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "WalletSolidity"
        ]
      },
      "post": {
        "operationId": "WalletSolidity_GetPaginatedAssetIssueList",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolAssetIssueList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolPaginatedMessage"
            }
          }
        ],
        "tags": [
          "WalletSolidity"
        ]
      }
    },
    "/walletsolidity/gettransactionbyid": {
      "get": {
        "operationId": "WalletSolidity_GetTransactionById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "value",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WalletSolidity"
        ]
      },
      "post": {
        "operationId": "WalletSolidity_GetTransactionById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransaction"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolBytesMessage"
            }
          }
        ],
        "tags": [
          "WalletSolidity"
        ]
      }
    },
    "/walletsolidity/gettransactioninfobyid": {
      "get": {
        "operationId": "WalletSolidity_GetTransactionInfoById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransactionInfo"
            }
          }
        },
        "parameters": [
          {
            "name": "value",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WalletSolidity"
        ]
      },
      "post": {
        "operationId": "WalletSolidity_GetTransactionInfoById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolTransactionInfo"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolBytesMessage"
            }
          }
        ],
        "tags": [
          "WalletSolidity"
        ]
      }
    },
    "/walletsolidity/listwitnesses": {
      "get": {
        "operationId": "WalletSolidity_ListWitnesses2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolWitnessList"
            }
          }
        },
        "tags": [
          "WalletSolidity"
        ]
      },
      "post": {
        "operationId": "WalletSolidity_ListWitnesses",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protocolWitnessList"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/protocolEmptyMessage"
            }
          }
        ],
        "tags": [
          "WalletSolidity"
        ]
      }
    }
  },
  "definitions": {
    "ABIEntry": {
      "type": "object",
      "properties": {
        "anonymous": {
          "type": "boolean"
        },
        "constant": {
          "type": "boolean"
        },
        "name": {
          "type": "string"
        },
        "inputs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EntryParam"
          }
        },
        "outputs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EntryParam"
          }
        },
        "type": {
          "$ref": "#/definitions/EntryEntryType"
        },
        "payable": {
          "type": "boolean"
        },
        "stateMutability": {
          "$ref": "#/definitions/EntryStateMutabilityType"
        }
      }
    },
    "AccountAccountResource": {
      "type": "object",
      "properties": {
        "energyUsage": {
          "type": "string",
          "format": "int64",
          "title": "energy resource, get from frozen"
        },
        "frozenBalanceForEnergy": {
          "$ref": "#/definitions/AccountFrozen",
          "title": "the frozen balance for energy"
        },
        "latestConsumeTimeForEnergy": {
          "type": "string",
          "format": "int64"
        },
        "acquiredDelegatedFrozenBalanceForEnergy": {
          "type": "string",
          "format": "int64",
          "title": "Frozen balance provided by other accounts to this account"
        },
        "delegatedFrozenBalanceForEnergy": {
          "type": "string",
          "format": "int64",
          "title": "Frozen balances provided to other accounts"
        },
        "storageLimit": {
          "type": "string",
          "format": "int64",
          "title": "storage resource, get from market"
        },
        "storageUsage": {
          "type": "string",
          "format": "int64"
        },
        "latestExchangeStorageTime": {
          "type": "string",
          "format": "int64"
        },
        "energyWindowSize": {
          "type": "string",
          "format": "int64"
        },
        "delegatedFrozenV2BalanceForEnergy": {
          "type": "string",
          "format": "int64"
        },
        "acquiredDelegatedFrozenV2BalanceForEnergy": {
          "type": "string",
          "format": "int64"
        },
        "energyWindowOptimized": {
          "type": "boolean"
        }
      }
    },
    "AccountFreezeV2": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/protocolResourceCode"
        },
        "amount": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "AccountFrozen": {
      "type": "object",
      "properties": {
        "frozenBalance": {
          "type": "string",
          "format": "int64"
        },
        "expireTime": {
          "type": "string",
          "format": "int64"
        }
      },
      "title": "frozen balance"
    },
    "AccountUnFreezeV2": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/protocolResourceCode"
        },
        "unfreezeAmount": {
          "type": "string",
          "format": "int64"
        },
        "unfreezeExpireTime": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "ApiInfoApiDetailInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "qps": {
          "$ref": "#/definitions/MetricsInfoRateInfo"
        },
        "failQps": {
          "$ref": "#/definitions/MetricsInfoRateInfo"
        },
        "outTraffic": {
          "$ref": "#/definitions/MetricsInfoRateInfo"
        }
      }
    },
    "AssetIssueContractFrozenSupply": {
      "type": "object",
      "properties": {
        "frozenAmount": {
          "type": "string",
          "format": "int64"
        },
        "frozenDays": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "BlockBalanceTraceBlockIdentifier": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "format": "byte"
        },
        "number": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "BlockChainInfoDupWitness": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string"
        },
        "blockNum": {
          "type": "string",
          "format": "int64"
        },
        "count": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "ChainParametersChainParameter": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "ContractContractType": {
      "type": "string",
      "enum": [
        "AccountCreateContract",
        "TransferContract",
        "TransferAssetContract",
        "VoteAssetContract",
        "VoteWitnessContract",
        "WitnessCreateContract",
        "AssetIssueContract",
        "WitnessUpdateContract",
        "ParticipateAssetIssueContract",
        "AccountUpdateContract",
        "FreezeBalanceContract",
        "UnfreezeBalanceContract",
        "WithdrawBalanceContract",
        "UnfreezeAssetContract",
        "UpdateAssetContract",
        "ProposalCreateContract",
        "ProposalApproveContract",
        "ProposalDeleteContract",
        "SetAccountIdContract",
        "CustomContract",
        "CreateSmartContract",
        "TriggerSmartContract",
        "GetContract",
        "UpdateSettingContract",
        "ExchangeCreateContract",
        "ExchangeInjectContract",
        "ExchangeWithdrawContract",
        "ExchangeTransactionContract",
        "UpdateEnergyLimitContract",
        "AccountPermissionUpdateContract",
        "ClearABIContract",
        "UpdateBrokerageContract",
        "ShieldedTransferContract",
        "MarketSellAssetContract",
        "MarketCancelOrderContract",
        "FreezeBalanceV2Contract",
        "UnfreezeBalanceV2Contract",
        "WithdrawExpireUnfreezeContract",
        "DelegateResourceContract",
        "UnDelegateResourceContract",
        "CancelAllUnfreezeV2Contract"
      ],
      "default": "AccountCreateContract"
    },
    "EntryEntryType": {
      "type": "string",
      "enum": [
        "UnknownEntryType",
        "Constructor",
        "Function",
        "Event",
        "Fallback",
        "Receive",
        "Error"
      ],
      "default": "UnknownEntryType"
    },
    "EntryParam": {
      "type": "object",
      "properties": {
        "indexed": {
          "type": "boolean"
        },
        "name": {
          "type": "string"
        },
        "type": {
          "type": "string"
        }
      }
    },
    "EntryStateMutabilityType": {
      "type": "string",
      "enum": [
        "UnknownMutabilityType",
        "Pure",
        "View",
        "Nonpayable",
        "Payable"
      ],
      "default": "UnknownMutabilityType"
    },
    "InternalTransactionCallValueInfo": {
      "type": "object",
      "properties": {
        "callValue": {
          "type": "string",
          "format": "int64",
          "title": "trx (TBD: or token) value"
        },
        "tokenId": {
          "type": "string",
          "title": "TBD: tokenName, trx should be empty"
        }
      }
    },
    "LatencyInfoLatencyDetailInfo": {
      "type": "object",
      "properties": {
        "witness": {
          "type": "string"
        },
        "top99": {
          "type": "integer",
          "format": "int32"
        },
        "top95": {
          "type": "integer",
          "format": "int32"
        },
        "top75": {
          "type": "integer",
          "format": "int32"
        },
        "count": {
          "type": "integer",
          "format": "int32"
        },
        "delay1S": {
          "type": "integer",
          "format": "int32"
        },
        "delay2S": {
          "type": "integer",
          "format": "int32"
        },
        "delay3S": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "MachineInfoDeadLockThreadInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "lockName": {
          "type": "string"
        },
        "lockOwner": {
          "type": "string"
        },
        "state": {
          "type": "string"
        },
        "blockTime": {
          "type": "string",
          "format": "int64"
        },
        "waitTime": {
          "type": "string",
          "format": "int64"
        },
        "stackTrace": {
          "type": "string"
        }
      }
    },
    "MachineInfoMemoryDescInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "initSize": {
          "type": "string",
          "format": "int64"
        },
        "useSize": {
          "type": "string",
          "format": "int64"
        },
        "maxSize": {
          "type": "string",
          "format": "int64"
        },
        "useRate": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "MetricsInfoBlockChainInfo": {
      "type": "object",
      "properties": {
        "headBlockNum": {
          "type": "string",
          "format": "int64"
        },
        "headBlockTimestamp": {
          "type": "string",
          "format": "int64"
        },
        "headBlockHash": {
          "type": "string"
        },
        "forkCount": {
          "type": "integer",
          "format": "int32"
        },
        "failForkCount": {
          "type": "integer",
          "format": "int32"
        },
        "blockProcessTime": {
          "$ref": "#/definitions/MetricsInfoRateInfo"
        },
        "tps": {
          "$ref": "#/definitions/MetricsInfoRateInfo"
        },
        "transactionCacheSize": {
          "type": "integer",
          "format": "int32"
        },
        "missedTransaction": {
          "$ref": "#/definitions/MetricsInfoRateInfo"
        },
        "witnesses": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MetricsInfoBlockChainInfoWitness"
          }
        },
        "failProcessBlockNum": {
          "type": "string",
          "format": "int64"
        },
        "failProcessBlockReason": {
          "type": "string"
        },
        "dupWitness": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BlockChainInfoDupWitness"
          }
        }
      }
    },
    "MetricsInfoBlockChainInfoWitness": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string"
        },
        "version": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "MetricsInfoNetInfo": {
      "type": "object",
      "properties": {
        "errorProtoCount": {
          "type": "integer",
          "format": "int32"
        },
        "api": {
          "$ref": "#/definitions/NetInfoApiInfo"
        },
        "connectionCount": {
          "type": "integer",
          "format": "int32"
        },
        "validConnectionCount": {
          "type": "integer",
          "format": "int32"
        },
        "tcpInTraffic": {
          "$ref": "#/definitions/MetricsInfoRateInfo"
        },
        "tcpOutTraffic": {
          "$ref": "#/definitions/MetricsInfoRateInfo"
        },
        "disconnectionCount": {
          "type": "integer",
          "format": "int32"
        },
        "disconnectionDetail": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NetInfoDisconnectionDetailInfo"
          }
        },
        "udpInTraffic": {
          "$ref": "#/definitions/MetricsInfoRateInfo"
        },
        "udpOutTraffic": {
          "$ref": "#/definitions/MetricsInfoRateInfo"
        },
        "latency": {
          "$ref": "#/definitions/NetInfoLatencyInfo"
        }
      }
    },
    "MetricsInfoRateInfo": {
      "type": "object",
      "properties": {
        "count": {
          "type": "string",
          "format": "int64"
        },
        "meanRate": {
          "type": "number",
          "format": "double"
        },
        "oneMinuteRate": {
          "type": "number",
          "format": "double"
        },
        "fiveMinuteRate": {
          "type": "number",
          "format": "double"
        },
        "fifteenMinuteRate": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "NetInfoApiInfo": {
      "type": "object",
      "properties": {
        "qps": {
          "$ref": "#/definitions/MetricsInfoRateInfo"
        },
        "failQps": {
          "$ref": "#/definitions/MetricsInfoRateInfo"
        },
        "outTraffic": {
          "$ref": "#/definitions/MetricsInfoRateInfo"
        },
        "detail": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ApiInfoApiDetailInfo"
          }
        }
      }
    },
    "NetInfoDisconnectionDetailInfo": {
      "type": "object",
      "properties": {
        "reason": {
          "type": "string"
        },
        "count": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "NetInfoLatencyInfo": {
      "type": "object",
      "properties": {
        "top99": {
          "type": "integer",
          "format": "int32"
        },
        "top95": {
          "type": "integer",
          "format": "int32"
        },
        "top75": {
          "type": "integer",
          "format": "int32"
        },
        "totalCount": {
          "type": "integer",
          "format": "int32"
        },
        "delay1S": {
          "type": "integer",
          "format": "int32"
        },
        "delay2S": {
          "type": "integer",
          "format": "int32"
        },
        "delay3S": {
          "type": "integer",
          "format": "int32"
        },
        "detail": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LatencyInfoLatencyDetailInfo"
          }
        }
      }
    },
    "NodeInfoConfigNodeInfo": {
      "type": "object",
      "properties": {
        "codeVersion": {
          "type": "string"
        },
        "p2pVersion": {
          "type": "string"
        },
        "listenPort": {
          "type": "integer",
          "format": "int32"
        },
        "discoverEnable": {
          "type": "boolean"
        },
        "activeNodeSize": {
          "type": "integer",
          "format": "int32"
        },
        "passiveNodeSize": {
          "type": "integer",
          "format": "int32"
        },
        "sendNodeSize": {
          "type": "integer",
          "format": "int32"
        },
        "maxConnectCount": {
          "type": "integer",
          "format": "int32"
        },
        "sameIpMaxConnectCount": {
          "type": "integer",
          "format": "int32"
        },
        "backupListenPort": {
          "type": "integer",
          "format": "int32"
        },
        "backupMemberSize": {
          "type": "integer",
          "format": "int32"
        },
        "backupPriority": {
          "type": "integer",
          "format": "int32"
        },
        "dbVersion": {
          "type": "integer",
          "format": "int32"
        },
        "minParticipationRate": {
          "type": "integer",
          "format": "int32"
        },
        "supportConstant": {
          "type": "boolean"
        },
        "minTimeRatio": {
          "type": "number",
          "format": "double"
        },
        "maxTimeRatio": {
          "type": "number",
          "format": "double"
        },
        "allowCreationOfContracts": {
          "type": "string",
          "format": "int64"
        },
        "allowAdaptiveEnergy": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "NodeInfoMachineInfo": {
      "type": "object",
      "properties": {
        "threadCount": {
          "type": "integer",
          "format": "int32"
        },
        "deadLockThreadCount": {
          "type": "integer",
          "format": "int32"
        },
        "cpuCount": {
          "type": "integer",
          "format": "int32"
        },
        "totalMemory": {
          "type": "string",
          "format": "int64"
        },
        "freeMemory": {
          "type": "string",
          "format": "int64"
        },
        "cpuRate": {
          "type": "number",
          "format": "double"
        },
        "javaVersion": {
          "type": "string"
        },
        "osName": {
          "type": "string"
        },
        "jvmTotalMemory": {
          "type": "string",
          "format": "int64"
        },
        "jvmFreeMemory": {
          "type": "string",
          "format": "int64"
        },
        "processCpuRate": {
          "type": "number",
          "format": "double"
        },
        "memoryDescInfoList": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MachineInfoMemoryDescInfo"
          }
        },
        "deadLockThreadInfoList": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MachineInfoDeadLockThreadInfo"
          }
        }
      }
    },
    "NodeInfoPeerInfo": {
      "type": "object",
      "properties": {
        "lastSyncBlock": {
          "type": "string"
        },
        "remainNum": {
          "type": "string",
          "format": "int64"
        },
        "lastBlockUpdateTime": {
          "type": "string",
          "format": "int64"
        },
        "syncFlag": {
          "type": "boolean"
        },
        "headBlockTimeWeBothHave": {
          "type": "string",
          "format": "int64"
        },
        "needSyncFromPeer": {
          "type": "boolean"
        },
        "needSyncFromUs": {
          "type": "boolean"
        },
        "host": {
          "type": "string"
        },
        "port": {
          "type": "integer",
          "format": "int32"
        },
        "nodeId": {
          "type": "string"
        },
        "connectTime": {
          "type": "string",
          "format": "int64"
        },
        "avgLatency": {
          "type": "number",
          "format": "double"
        },
        "syncToFetchSize": {
          "type": "integer",
          "format": "int32"
        },
        "syncToFetchSizePeekNum": {
          "type": "string",
          "format": "int64"
        },
        "syncBlockRequestedSize": {
          "type": "integer",
          "format": "int32"
        },
        "unFetchSynNum": {
          "type": "string",
          "format": "int64"
        },
        "blockInPorcSize": {
          "type": "integer",
          "format": "int32"
        },
        "headBlockWeBothHave": {
          "type": "string"
        },
        "isActive": {
          "type": "boolean"
        },
        "score": {
          "type": "integer",
          "format": "int32"
        },
        "nodeCount": {
          "type": "integer",
          "format": "int32"
        },
        "inFlow": {
          "type": "string",
          "format": "int64"
        },
        "disconnectTimes": {
          "type": "integer",
          "format": "int32"
        },
        "localDisconnectReason": {
          "type": "string"
        },
        "remoteDisconnectReason": {
          "type": "string"
        }
      }
    },
    "PermissionPermissionType": {
      "type": "string",
      "enum": [
        "Owner",
        "Witness",
        "Active"
      ],
      "default": "Owner"
    },
    "ResultcontractResult": {
      "type": "string",
      "enum": [
        "DEFAULT",
        "SUCCESS",
        "REVERT",
        "BAD_JUMP_DESTINATION",
        "OUT_OF_MEMORY",
        "PRECOMPILED_CONTRACT",
        "STACK_TOO_SMALL",
        "STACK_TOO_LARGE",
        "ILLEGAL_OPERATION",
        "STACK_OVERFLOW",
        "OUT_OF_ENERGY",
        "OUT_OF_TIME",
        "JVM_STACK_OVER_FLOW",
        "UNKNOWN",
        "TRANSFER_FAILED",
        "INVALID_CODE"
      ],
      "default": "DEFAULT"
    },
    "SmartContractABI": {
      "type": "object",
      "properties": {
        "entrys": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ABIEntry"
          }
        }
      }
    },
    "TransactionBalanceTraceOperation": {
      "type": "object",
      "properties": {
        "operationIdentifier": {
          "type": "string",
          "format": "int64"
        },
        "address": {
          "type": "string",
          "format": "byte"
        },
        "amount": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "TransactionContract": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/ContractContractType"
        },
        "parameter": {
          "$ref": "#/definitions/protobufAny"
        },
        "provider": {
          "type": "string",
          "format": "byte"
        },
        "ContractName": {
          "type": "string",
          "format": "byte"
        },
        "PermissionId": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "TransactionInfoLog": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "format": "byte"
        },
        "topics": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          }
        },
        "data": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "TransactionResultcode": {
      "type": "string",
      "enum": [
        "SUCESS",
        "FAILED"
      ],
      "default": "SUCESS"
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "typeUrl": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n` + "``" + `path/google.protobuf.Duration` + "``" + `). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme ` + "``" + `http` + "``" + `, ` + "``" + `https` + "``" + `, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, ` + "``" + `https` + "``" + ` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than ` + "``" + `http` + "``" + `, ` + "``" + `https` + "``" + ` (or the empty scheme) might be\nused with implementation specific semantics."
        },
        "value": {
          "type": "string",
          "format": "byte",
          "description": "Must be a valid serialized protocol buffer of the above specified type."
        }
      },
      "description": "` + "``" + `Any` + "``" + ` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an ` + "``" + `Any` + "``" + ` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field ` + "``" + `@type` + "``" + ` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n` + "``" + `value` + "``" + ` which holds the custom JSON in addition to the ` + "``" + `@type` + "``" + `\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "protocolAccount": {
      "type": "object",
      "properties": {
        "accountName": {
          "type": "string",
          "format": "byte",
          "title": "account nick name"
        },
        "type": {
          "$ref": "#/definitions/protocolAccountType"
        },
        "address": {
          "type": "string",
          "format": "byte",
          "title": "the create address"
        },
        "balance": {
          "type": "string",
          "format": "int64",
          "title": "the trx balance"
        },
        "votes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolVote"
          },
          "title": "the votes"
        },
        "asset": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          },
          "title": "the other asset owned by this account"
        },
        "assetV2": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          },
          "title": "the other asset owned by this account，key is assetId"
        },
        "frozen": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AccountFrozen"
          },
          "title": "the frozen balance for bandwidth"
        },
        "netUsage": {
          "type": "string",
          "format": "int64",
          "title": "bandwidth, get from frozen"
        },
        "acquiredDelegatedFrozenBalanceForBandwidth": {
          "type": "string",
          "format": "int64",
          "title": "Frozen balance provided by other accounts to this account"
        },
        "delegatedFrozenBalanceForBandwidth": {
          "type": "string",
          "format": "int64",
          "title": "Freeze and provide balances to other accounts"
        },
        "oldTronPower": {
          "type": "string",
          "format": "int64"
        },
        "tronPower": {
          "$ref": "#/definitions/AccountFrozen"
        },
        "assetOptimized": {
          "type": "boolean"
        },
        "createTime": {
          "type": "string",
          "format": "int64",
          "title": "this account create time"
        },
        "latestOprationTime": {
          "type": "string",
          "format": "int64",
          "title": "this last operation time, including transfer, voting and so on. //FIXME fix grammar"
        },
        "allowance": {
          "type": "string",
          "format": "int64",
          "title": "witness block producing allowance"
        },
        "latestWithdrawTime": {
          "type": "string",
          "format": "int64",
          "title": "last withdraw time"
        },
        "code": {
          "type": "string",
          "format": "byte",
          "title": "not used so far"
        },
        "isWitness": {
          "type": "boolean"
        },
        "isCommittee": {
          "type": "boolean"
        },
        "frozenSupply": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AccountFrozen"
          },
          "title": "frozen asset(for asset issuer)"
        },
        "assetIssuedName": {
          "type": "string",
          "format": "byte",
          "title": "asset_issued_name"
        },
        "assetIssuedID": {
          "type": "string",
          "format": "byte"
        },
        "latestAssetOperationTime": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          }
        },
        "latestAssetOperationTimeV2": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          }
        },
        "freeNetUsage": {
          "type": "string",
          "format": "int64"
        },
        "freeAssetNetUsage": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          }
        },
        "freeAssetNetUsageV2": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          }
        },
        "latestConsumeTime": {
          "type": "string",
          "format": "int64"
        },
        "latestConsumeFreeTime": {
          "type": "string",
          "format": "int64"
        },
        "accountId": {
          "type": "string",
          "format": "byte",
          "title": "the identity of this account, case insensitive"
        },
        "netWindowSize": {
          "type": "string",
          "format": "int64"
        },
        "netWindowOptimized": {
          "type": "boolean"
        },
        "accountResource": {
          "$ref": "#/definitions/AccountAccountResource"
        },
        "codeHash": {
          "type": "string",
          "format": "byte"
        },
        "ownerPermission": {
          "$ref": "#/definitions/protocolPermission"
        },
        "witnessPermission": {
          "$ref": "#/definitions/protocolPermission"
        },
        "activePermission": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolPermission"
          }
        },
        "frozenV2": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AccountFreezeV2"
          }
        },
        "unfrozenV2": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AccountUnFreezeV2"
          }
        },
        "delegatedFrozenV2BalanceForBandwidth": {
          "type": "string",
          "format": "int64"
        },
        "acquiredDelegatedFrozenV2BalanceForBandwidth": {
          "type": "string",
          "format": "int64"
        }
      },
      "title": "Account"
    },
    "protocolAccountBalanceRequest": {
      "type": "object",
      "properties": {
        "accountIdentifier": {
          "$ref": "#/definitions/protocolAccountIdentifier"
        },
        "blockIdentifier": {
          "$ref": "#/definitions/BlockBalanceTraceBlockIdentifier"
        }
      }
    },
    "protocolAccountBalanceResponse": {
      "type": "object",
      "properties": {
        "balance": {
          "type": "string",
          "format": "int64"
        },
        "blockIdentifier": {
          "$ref": "#/definitions/BlockBalanceTraceBlockIdentifier"
        }
      }
    },
    "protocolAccountCreateContract": {
      "type": "object",
      "properties": {
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        },
        "accountAddress": {
          "type": "string",
          "format": "byte"
        },
        "type": {
          "$ref": "#/definitions/protocolAccountType"
        }
      }
    },
    "protocolAccountId": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "format": "byte"
        },
        "address": {
          "type": "string",
          "format": "byte"
        }
      },
      "title": "AccountId, (name, address) use name, (null, address) use address, (name, null) use name,"
    },
    "protocolAccountIdentifier": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolAccountNetMessage": {
      "type": "object",
      "properties": {
        "freeNetUsed": {
          "type": "string",
          "format": "int64"
        },
        "freeNetLimit": {
          "type": "string",
          "format": "int64"
        },
        "NetUsed": {
          "type": "string",
          "format": "int64"
        },
        "NetLimit": {
          "type": "string",
          "format": "int64"
        },
        "assetNetUsed": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          }
        },
        "assetNetLimit": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          }
        },
        "TotalNetLimit": {
          "type": "string",
          "format": "int64"
        },
        "TotalNetWeight": {
          "type": "string",
          "format": "int64"
        }
      },
      "title": "deprecated"
    },
    "protocolAccountPaginated": {
      "type": "object",
      "properties": {
        "account": {
          "$ref": "#/definitions/protocolAccount"
        },
        "offset": {
          "type": "string",
          "format": "int64"
        },
        "limit": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolAccountPermissionUpdateContract": {
      "type": "object",
      "properties": {
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        },
        "owner": {
          "$ref": "#/definitions/protocolPermission"
        },
        "witness": {
          "$ref": "#/definitions/protocolPermission"
        },
        "actives": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolPermission"
          }
        }
      }
    },
    "protocolAccountResourceMessage": {
      "type": "object",
      "properties": {
        "freeNetUsed": {
          "type": "string",
          "format": "int64"
        },
        "freeNetLimit": {
          "type": "string",
          "format": "int64"
        },
        "NetUsed": {
          "type": "string",
          "format": "int64"
        },
        "NetLimit": {
          "type": "string",
          "format": "int64"
        },
        "assetNetUsed": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          }
        },
        "assetNetLimit": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          }
        },
        "TotalNetLimit": {
          "type": "string",
          "format": "int64"
        },
        "TotalNetWeight": {
          "type": "string",
          "format": "int64"
        },
        "TotalTronPowerWeight": {
          "type": "string",
          "format": "int64"
        },
        "tronPowerUsed": {
          "type": "string",
          "format": "int64"
        },
        "tronPowerLimit": {
          "type": "string",
          "format": "int64"
        },
        "EnergyUsed": {
          "type": "string",
          "format": "int64"
        },
        "EnergyLimit": {
          "type": "string",
          "format": "int64"
        },
        "TotalEnergyLimit": {
          "type": "string",
          "format": "int64"
        },
        "TotalEnergyWeight": {
          "type": "string",
          "format": "int64"
        },
        "storageUsed": {
          "type": "string",
          "format": "int64"
        },
        "storageLimit": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolAccountType": {
      "type": "string",
      "enum": [
        "Normal",
        "AssetIssue",
        "Contract"
      ],
      "default": "Normal"
    },
    "protocolAccountUpdateContract": {
      "type": "object",
      "properties": {
        "accountName": {
          "type": "string",
          "format": "byte"
        },
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Update account name. Account name is not unique now."
    },
    "protocolAddress": {
      "type": "object",
      "properties": {
        "host": {
          "type": "string",
          "format": "byte"
        },
        "port": {
          "type": "integer",
          "format": "int32"
        }
      },
      "title": "Gossip node address"
    },
    "protocolAssetIssueContract": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        },
        "name": {
          "type": "string",
          "format": "byte"
        },
        "abbr": {
          "type": "string",
          "format": "byte"
        },
        "totalSupply": {
          "type": "string",
          "format": "int64"
        },
        "frozenSupply": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AssetIssueContractFrozenSupply"
          }
        },
        "trxNum": {
          "type": "integer",
          "format": "int32"
        },
        "precision": {
          "type": "integer",
          "format": "int32"
        },
        "num": {
          "type": "integer",
          "format": "int32"
        },
        "startTime": {
          "type": "string",
          "format": "int64"
        },
        "endTime": {
          "type": "string",
          "format": "int64"
        },
        "order": {
          "type": "string",
          "format": "int64"
        },
        "voteScore": {
          "type": "integer",
          "format": "int32"
        },
        "description": {
          "type": "string",
          "format": "byte"
        },
        "url": {
          "type": "string",
          "format": "byte"
        },
        "freeAssetNetLimit": {
          "type": "string",
          "format": "int64"
        },
        "publicFreeAssetNetLimit": {
          "type": "string",
          "format": "int64"
        },
        "publicFreeAssetNetUsage": {
          "type": "string",
          "format": "int64"
        },
        "publicLatestFreeNetTime": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolAssetIssueList": {
      "type": "object",
      "properties": {
        "assetIssue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolAssetIssueContract"
          }
        }
      }
    },
    "protocolBlock": {
      "type": "object",
      "properties": {
        "transactions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolTransaction"
          }
        },
        "blockHeader": {
          "$ref": "#/definitions/protocolBlockHeader"
        }
      },
      "title": "block"
    },
    "protocolBlockBalanceTrace": {
      "type": "object",
      "properties": {
        "blockIdentifier": {
          "$ref": "#/definitions/BlockBalanceTraceBlockIdentifier"
        },
        "timestamp": {
          "type": "string",
          "format": "int64"
        },
        "transactionBalanceTrace": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolTransactionBalanceTrace"
          }
        }
      }
    },
    "protocolBlockExtention": {
      "type": "object",
      "properties": {
        "transactions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolTransactionExtention"
          }
        },
        "blockHeader": {
          "$ref": "#/definitions/protocolBlockHeader"
        },
        "blockid": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolBlockHeader": {
      "type": "object",
      "properties": {
        "rawData": {
          "$ref": "#/definitions/protocolBlockHeaderraw"
        },
        "witnessSignature": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolBlockHeaderraw": {
      "type": "object",
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "int64"
        },
        "txTrieRoot": {
          "type": "string",
          "format": "byte"
        },
        "parentHash": {
          "type": "string",
          "format": "byte"
        },
        "number": {
          "type": "string",
          "format": "int64",
          "title": "bytes nonce = 5;\nbytes difficulty = 6;"
        },
        "witnessId": {
          "type": "string",
          "format": "int64"
        },
        "witnessAddress": {
          "type": "string",
          "format": "byte"
        },
        "version": {
          "type": "integer",
          "format": "int32"
        },
        "accountStateRoot": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolBlockLimit": {
      "type": "object",
      "properties": {
        "startNum": {
          "type": "string",
          "format": "int64"
        },
        "endNum": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolBlockList": {
      "type": "object",
      "properties": {
        "block": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolBlock"
          }
        }
      }
    },
    "protocolBlockListExtention": {
      "type": "object",
      "properties": {
        "block": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolBlockExtention"
          }
        }
      }
    },
    "protocolBlockReference": {
      "type": "object",
      "properties": {
        "blockNum": {
          "type": "string",
          "format": "int64"
        },
        "blockHash": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolBytesMessage": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolCanDelegatedMaxSizeResponseMessage": {
      "type": "object",
      "properties": {
        "maxSize": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolCanWithdrawUnfreezeAmountResponseMessage": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolChainParameters": {
      "type": "object",
      "properties": {
        "chainParameter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ChainParametersChainParameter"
          }
        }
      }
    },
    "protocolContractState": {
      "type": "object",
      "properties": {
        "energyUsage": {
          "type": "string",
          "format": "int64"
        },
        "energyFactor": {
          "type": "string",
          "format": "int64"
        },
        "updateCycle": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolDecryptNotes": {
      "type": "object",
      "properties": {
        "noteTxs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolDecryptNotesNoteTx"
          }
        }
      }
    },
    "protocolDecryptNotesMarked": {
      "type": "object",
      "properties": {
        "noteTxs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolDecryptNotesMarkedNoteTx"
          }
        }
      }
    },
    "protocolDecryptNotesMarkedNoteTx": {
      "type": "object",
      "properties": {
        "note": {
          "$ref": "#/definitions/protocolNote"
        },
        "txid": {
          "type": "string",
          "format": "byte"
        },
        "index": {
          "type": "integer",
          "format": "int32"
        },
        "isSpend": {
          "type": "boolean"
        }
      }
    },
    "protocolDecryptNotesNoteTx": {
      "type": "object",
      "properties": {
        "note": {
          "$ref": "#/definitions/protocolNote"
        },
        "txid": {
          "type": "string",
          "format": "byte"
        },
        "index": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "protocolDecryptNotesTRC20": {
      "type": "object",
      "properties": {
        "noteTxs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolDecryptNotesTRC20NoteTx"
          }
        }
      }
    },
    "protocolDecryptNotesTRC20NoteTx": {
      "type": "object",
      "properties": {
        "note": {
          "$ref": "#/definitions/protocolNote"
        },
        "position": {
          "type": "string",
          "format": "int64"
        },
        "isSpent": {
          "type": "boolean"
        },
        "txid": {
          "type": "string",
          "format": "byte"
        },
        "index": {
          "type": "integer",
          "format": "int32"
        },
        "toAmount": {
          "type": "string"
        },
        "transparentToAddress": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolDelegatedResource": {
      "type": "object",
      "properties": {
        "from": {
          "type": "string",
          "format": "byte"
        },
        "to": {
          "type": "string",
          "format": "byte"
        },
        "frozenBalanceForBandwidth": {
          "type": "string",
          "format": "int64"
        },
        "frozenBalanceForEnergy": {
          "type": "string",
          "format": "int64"
        },
        "expireTimeForBandwidth": {
          "type": "string",
          "format": "int64"
        },
        "expireTimeForEnergy": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolDelegatedResourceAccountIndex": {
      "type": "object",
      "properties": {
        "account": {
          "type": "string",
          "format": "byte"
        },
        "fromAccounts": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          }
        },
        "toAccounts": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          }
        },
        "timestamp": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolDelegatedResourceList": {
      "type": "object",
      "properties": {
        "delegatedResource": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolDelegatedResource"
          }
        }
      }
    },
    "protocolDiversifierMessage": {
      "type": "object",
      "properties": {
        "d": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolDynamicProperties": {
      "type": "object",
      "properties": {
        "lastSolidityBlockNum": {
          "type": "string",
          "format": "int64"
        }
      },
      "title": "DynamicProperties"
    },
    "protocolEmptyMessage": {
      "type": "object"
    },
    "protocolEstimateEnergyMessage": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/protocolReturn"
        },
        "energyRequired": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolExchange": {
      "type": "object",
      "properties": {
        "exchangeId": {
          "type": "string",
          "format": "int64"
        },
        "creatorAddress": {
          "type": "string",
          "format": "byte"
        },
        "createTime": {
          "type": "string",
          "format": "int64"
        },
        "firstTokenId": {
          "type": "string",
          "format": "byte"
        },
        "firstTokenBalance": {
          "type": "string",
          "format": "int64"
        },
        "secondTokenId": {
          "type": "string",
          "format": "byte"
        },
        "secondTokenBalance": {
          "type": "string",
          "format": "int64"
        }
      },
      "title": "Exchange"
    },
    "protocolExchangeList": {
      "type": "object",
      "properties": {
        "exchanges": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolExchange"
          }
        }
      }
    },
    "protocolExpandedSpendingKeyMessage": {
      "type": "object",
      "properties": {
        "ask": {
          "type": "string",
          "format": "byte"
        },
        "nsk": {
          "type": "string",
          "format": "byte"
        },
        "ovk": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolFreezeBalanceContract": {
      "type": "object",
      "properties": {
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        },
        "frozenBalance": {
          "type": "string",
          "format": "int64"
        },
        "frozenDuration": {
          "type": "string",
          "format": "int64"
        },
        "resource": {
          "$ref": "#/definitions/protocolResourceCode"
        },
        "receiverAddress": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolGetAvailableUnfreezeCountResponseMessage": {
      "type": "object",
      "properties": {
        "count": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolIncomingViewingKeyMessage": {
      "type": "object",
      "properties": {
        "ivk": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolIncrementalMerkleTree": {
      "type": "object",
      "properties": {
        "left": {
          "$ref": "#/definitions/protocolPedersenHash"
        },
        "right": {
          "$ref": "#/definitions/protocolPedersenHash"
        },
        "parents": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolPedersenHash"
          }
        }
      }
    },
    "protocolIncrementalMerkleVoucher": {
      "type": "object",
      "properties": {
        "tree": {
          "$ref": "#/definitions/protocolIncrementalMerkleTree"
        },
        "filled": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolPedersenHash"
          }
        },
        "cursor": {
          "$ref": "#/definitions/protocolIncrementalMerkleTree"
        },
        "cursorDepth": {
          "type": "string",
          "format": "int64"
        },
        "rt": {
          "type": "string",
          "format": "byte"
        },
        "outputPoint": {
          "$ref": "#/definitions/protocolOutputPoint"
        }
      }
    },
    "protocolIncrementalMerkleVoucherInfo": {
      "type": "object",
      "properties": {
        "vouchers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolIncrementalMerkleVoucher"
          }
        },
        "paths": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          }
        }
      }
    },
    "protocolInternalTransaction": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "format": "byte",
          "description": "internalTransaction identity, the root InternalTransaction hash\nshould equals to root transaction id."
        },
        "callerAddress": {
          "type": "string",
          "format": "byte",
          "title": "the one send trx (TBD: or token) via function"
        },
        "transferToAddress": {
          "type": "string",
          "format": "byte",
          "title": "the one recieve trx (TBD: or token) via function"
        },
        "callValueInfo": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/InternalTransactionCallValueInfo"
          }
        },
        "note": {
          "type": "string",
          "format": "byte"
        },
        "rejected": {
          "type": "boolean"
        },
        "extra": {
          "type": "string"
        }
      }
    },
    "protocolKey": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "format": "byte"
        },
        "weight": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolMarketOrder": {
      "type": "object",
      "properties": {
        "orderId": {
          "type": "string",
          "format": "byte"
        },
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        },
        "createTime": {
          "type": "string",
          "format": "int64"
        },
        "sellTokenId": {
          "type": "string",
          "format": "byte"
        },
        "sellTokenQuantity": {
          "type": "string",
          "format": "int64"
        },
        "buyTokenId": {
          "type": "string",
          "format": "byte"
        },
        "buyTokenQuantity": {
          "type": "string",
          "format": "int64"
        },
        "sellTokenQuantityRemain": {
          "type": "string",
          "format": "int64"
        },
        "sellTokenQuantityReturn": {
          "type": "string",
          "format": "int64",
          "title": "When state != ACTIVE and sell_token_quantity_return !=0,\nit means that some sell tokens are returned to the account due to insufficient remaining amount"
        },
        "state": {
          "$ref": "#/definitions/protocolMarketOrderState"
        },
        "prev": {
          "type": "string",
          "format": "byte"
        },
        "next": {
          "type": "string",
          "format": "byte"
        }
      },
      "title": "market"
    },
    "protocolMarketOrderDetail": {
      "type": "object",
      "properties": {
        "makerOrderId": {
          "type": "string",
          "format": "byte"
        },
        "takerOrderId": {
          "type": "string",
          "format": "byte"
        },
        "fillSellQuantity": {
          "type": "string",
          "format": "int64"
        },
        "fillBuyQuantity": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolMarketOrderList": {
      "type": "object",
      "properties": {
        "orders": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolMarketOrder"
          }
        }
      }
    },
    "protocolMarketOrderPair": {
      "type": "object",
      "properties": {
        "sellTokenId": {
          "type": "string",
          "format": "byte"
        },
        "buyTokenId": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolMarketOrderPairList": {
      "type": "object",
      "properties": {
        "orderPair": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolMarketOrderPair"
          }
        }
      }
    },
    "protocolMarketOrderState": {
      "type": "string",
      "enum": [
        "ACTIVE",
        "INACTIVE",
        "CANCELED"
      ],
      "default": "ACTIVE"
    },
    "protocolMarketPrice": {
      "type": "object",
      "properties": {
        "sellTokenQuantity": {
          "type": "string",
          "format": "int64"
        },
        "buyTokenQuantity": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolMarketPriceList": {
      "type": "object",
      "properties": {
        "sellTokenId": {
          "type": "string",
          "format": "byte"
        },
        "buyTokenId": {
          "type": "string",
          "format": "byte"
        },
        "prices": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolMarketPrice"
          }
        }
      }
    },
    "protocolMetricsInfo": {
      "type": "object",
      "properties": {
        "interval": {
          "type": "string",
          "format": "int64"
        },
        "node": {
          "$ref": "#/definitions/protocolMetricsInfoNodeInfo"
        },
        "blockchain": {
          "$ref": "#/definitions/MetricsInfoBlockChainInfo"
        },
        "net": {
          "$ref": "#/definitions/MetricsInfoNetInfo"
        }
      }
    },
    "protocolMetricsInfoNodeInfo": {
      "type": "object",
      "properties": {
        "ip": {
          "type": "string"
        },
        "nodeType": {
          "type": "integer",
          "format": "int32"
        },
        "version": {
          "type": "string"
        },
        "backupStatus": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "protocolNode": {
      "type": "object",
      "properties": {
        "address": {
          "$ref": "#/definitions/protocolAddress"
        }
      },
      "title": "Gossip node"
    },
    "protocolNodeInfo": {
      "type": "object",
      "properties": {
        "beginSyncNum": {
          "type": "string",
          "format": "int64"
        },
        "block": {
          "type": "string"
        },
        "solidityBlock": {
          "type": "string"
        },
        "currentConnectCount": {
          "type": "integer",
          "format": "int32",
          "title": "connect information"
        },
        "activeConnectCount": {
          "type": "integer",
          "format": "int32"
        },
        "passiveConnectCount": {
          "type": "integer",
          "format": "int32"
        },
        "totalFlow": {
          "type": "string",
          "format": "int64"
        },
        "peerInfoList": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NodeInfoPeerInfo"
          }
        },
        "configNodeInfo": {
          "$ref": "#/definitions/NodeInfoConfigNodeInfo"
        },
        "machineInfo": {
          "$ref": "#/definitions/NodeInfoMachineInfo"
        },
        "cheatWitnessInfoMap": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "protocolNodeList": {
      "type": "object",
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolNode"
          }
        }
      },
      "title": "Gossip node list"
    },
    "protocolNote": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string",
          "format": "int64"
        },
        "paymentAddress": {
          "type": "string"
        },
        "rcm": {
          "type": "string",
          "format": "byte"
        },
        "memo": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolNullifierResult": {
      "type": "object",
      "properties": {
        "isSpent": {
          "type": "boolean"
        }
      }
    },
    "protocolNumberMessage": {
      "type": "object",
      "properties": {
        "num": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolOutputPoint": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "format": "byte"
        },
        "index": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "protocolPaginatedMessage": {
      "type": "object",
      "properties": {
        "offset": {
          "type": "string",
          "format": "int64"
        },
        "limit": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolParticipateAssetIssueContract": {
      "type": "object",
      "properties": {
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        },
        "toAddress": {
          "type": "string",
          "format": "byte"
        },
        "assetName": {
          "type": "string",
          "format": "byte"
        },
        "amount": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolPaymentAddressMessage": {
      "type": "object",
      "properties": {
        "d": {
          "$ref": "#/definitions/protocolDiversifierMessage"
        },
        "pkD": {
          "type": "string",
          "format": "byte"
        },
        "paymentAddress": {
          "type": "string"
        }
      }
    },
    "protocolPedersenHash": {
      "type": "object",
      "properties": {
        "content": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolPermission": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/PermissionPermissionType"
        },
        "id": {
          "type": "integer",
          "format": "int32"
        },
        "permissionName": {
          "type": "string"
        },
        "threshold": {
          "type": "string",
          "format": "int64"
        },
        "parentId": {
          "type": "integer",
          "format": "int32"
        },
        "operations": {
          "type": "string",
          "format": "byte"
        },
        "keys": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolKey"
          }
        }
      }
    },
    "protocolPricesResponseMessage": {
      "type": "object",
      "properties": {
        "prices": {
          "type": "string"
        }
      }
    },
    "protocolProposal": {
      "type": "object",
      "properties": {
        "proposalId": {
          "type": "string",
          "format": "int64"
        },
        "proposerAddress": {
          "type": "string",
          "format": "byte"
        },
        "parameters": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          }
        },
        "expirationTime": {
          "type": "string",
          "format": "int64"
        },
        "createTime": {
          "type": "string",
          "format": "int64"
        },
        "approvals": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          }
        },
        "state": {
          "$ref": "#/definitions/protocolProposalState"
        }
      },
      "title": "Proposal"
    },
    "protocolProposalList": {
      "type": "object",
      "properties": {
        "proposals": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolProposal"
          }
        }
      }
    },
    "protocolProposalState": {
      "type": "string",
      "enum": [
        "PENDING",
        "DISAPPROVED",
        "APPROVED",
        "CANCELED"
      ],
      "default": "PENDING"
    },
    "protocolReceiveDescription": {
      "type": "object",
      "properties": {
        "valueCommitment": {
          "type": "string",
          "format": "byte"
        },
        "noteCommitment": {
          "type": "string",
          "format": "byte"
        },
        "epk": {
          "type": "string",
          "format": "byte"
        },
        "cEnc": {
          "type": "string",
          "format": "byte"
        },
        "cOut": {
          "type": "string",
          "format": "byte"
        },
        "zkproof": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolReceiveNote": {
      "type": "object",
      "properties": {
        "note": {
          "$ref": "#/definitions/protocolNote"
        }
      }
    },
    "protocolResourceCode": {
      "type": "string",
      "enum": [
        "BANDWIDTH",
        "ENERGY",
        "TRON_POWER"
      ],
      "default": "BANDWIDTH"
    },
    "protocolResourceReceipt": {
      "type": "object",
      "properties": {
        "energyUsage": {
          "type": "string",
          "format": "int64"
        },
        "energyFee": {
          "type": "string",
          "format": "int64"
        },
        "originEnergyUsage": {
          "type": "string",
          "format": "int64"
        },
        "energyUsageTotal": {
          "type": "string",
          "format": "int64"
        },
        "netUsage": {
          "type": "string",
          "format": "int64"
        },
        "netFee": {
          "type": "string",
          "format": "int64"
        },
        "result": {
          "$ref": "#/definitions/ResultcontractResult"
        },
        "energyPenaltyTotal": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolReturn": {
      "type": "object",
      "properties": {
        "result": {
          "type": "boolean"
        },
        "code": {
          "$ref": "#/definitions/protocolReturnresponse_code"
        },
        "message": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolReturnresponse_code": {
      "type": "string",
      "enum": [
        "SUCCESS",
        "SIGERROR",
        "CONTRACT_VALIDATE_ERROR",
        "CONTRACT_EXE_ERROR",
        "BANDWITH_ERROR",
        "DUP_TRANSACTION_ERROR",
        "TAPOS_ERROR",
        "TOO_BIG_TRANSACTION_ERROR",
        "TRANSACTION_EXPIRATION_ERROR",
        "SERVER_BUSY",
        "NO_CONNECTION",
        "NOT_ENOUGH_EFFECTIVE_CONNECTION",
        "BLOCK_UNSOLIDIFIED",
        "OTHER_ERROR"
      ],
      "default": "SUCCESS"
    },
    "protocolSetAccountIdContract": {
      "type": "object",
      "properties": {
        "accountId": {
          "type": "string",
          "format": "byte"
        },
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Set account id if the account has no id. Account id is unique and case insensitive."
    },
    "protocolShieldedAddressInfo": {
      "type": "object",
      "properties": {
        "sk": {
          "type": "string",
          "format": "byte"
        },
        "ask": {
          "type": "string",
          "format": "byte"
        },
        "nsk": {
          "type": "string",
          "format": "byte"
        },
        "ovk": {
          "type": "string",
          "format": "byte"
        },
        "ak": {
          "type": "string",
          "format": "byte"
        },
        "nk": {
          "type": "string",
          "format": "byte"
        },
        "ivk": {
          "type": "string",
          "format": "byte"
        },
        "d": {
          "type": "string",
          "format": "byte"
        },
        "pkD": {
          "type": "string",
          "format": "byte"
        },
        "paymentAddress": {
          "type": "string"
        }
      }
    },
    "protocolShieldedTRC20Parameters": {
      "type": "object",
      "properties": {
        "spendDescription": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolSpendDescription"
          }
        },
        "receiveDescription": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolReceiveDescription"
          }
        },
        "bindingSignature": {
          "type": "string",
          "format": "byte"
        },
        "messageHash": {
          "type": "string",
          "format": "byte"
        },
        "triggerContractInput": {
          "type": "string"
        },
        "parameterType": {
          "type": "string"
        }
      }
    },
    "protocolSmartContract": {
      "type": "object",
      "properties": {
        "originAddress": {
          "type": "string",
          "format": "byte"
        },
        "contractAddress": {
          "type": "string",
          "format": "byte"
        },
        "abi": {
          "$ref": "#/definitions/SmartContractABI"
        },
        "bytecode": {
          "type": "string",
          "format": "byte"
        },
        "callValue": {
          "type": "string",
          "format": "int64"
        },
        "consumeUserResourcePercent": {
          "type": "string",
          "format": "int64"
        },
        "name": {
          "type": "string"
        },
        "originEnergyLimit": {
          "type": "string",
          "format": "int64"
        },
        "codeHash": {
          "type": "string",
          "format": "byte"
        },
        "trxHash": {
          "type": "string",
          "format": "byte"
        },
        "version": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "protocolSmartContractDataWrapper": {
      "type": "object",
      "properties": {
        "smartContract": {
          "$ref": "#/definitions/protocolSmartContract"
        },
        "runtimecode": {
          "type": "string",
          "format": "byte"
        },
        "contractState": {
          "$ref": "#/definitions/protocolContractState"
        }
      }
    },
    "protocolSpendDescription": {
      "type": "object",
      "properties": {
        "valueCommitment": {
          "type": "string",
          "format": "byte"
        },
        "anchor": {
          "type": "string",
          "format": "byte"
        },
        "nullifier": {
          "type": "string",
          "format": "byte"
        },
        "rk": {
          "type": "string",
          "format": "byte"
        },
        "zkproof": {
          "type": "string",
          "format": "byte"
        },
        "spendAuthoritySignature": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolSpendNote": {
      "type": "object",
      "properties": {
        "note": {
          "$ref": "#/definitions/protocolNote"
        },
        "alpha": {
          "type": "string",
          "format": "byte"
        },
        "voucher": {
          "$ref": "#/definitions/protocolIncrementalMerkleVoucher"
        },
        "path": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolSpendNoteTRC20": {
      "type": "object",
      "properties": {
        "note": {
          "$ref": "#/definitions/protocolNote"
        },
        "alpha": {
          "type": "string",
          "format": "byte"
        },
        "root": {
          "type": "string",
          "format": "byte"
        },
        "path": {
          "type": "string",
          "format": "byte"
        },
        "pos": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolSpendResult": {
      "type": "object",
      "properties": {
        "result": {
          "type": "boolean"
        },
        "message": {
          "type": "string"
        }
      }
    },
    "protocolTransaction": {
      "type": "object",
      "properties": {
        "rawData": {
          "$ref": "#/definitions/protocolTransactionraw"
        },
        "signature": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "title": "only support size = 1,  repeated list here for muti-sig extension"
        },
        "ret": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolTransactionResult"
          }
        }
      }
    },
    "protocolTransactionApprovedList": {
      "type": "object",
      "properties": {
        "approvedList": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          }
        },
        "result": {
          "$ref": "#/definitions/protocolTransactionApprovedListResult"
        },
        "transaction": {
          "$ref": "#/definitions/protocolTransactionExtention"
        }
      }
    },
    "protocolTransactionApprovedListResult": {
      "type": "object",
      "properties": {
        "code": {
          "$ref": "#/definitions/protocolTransactionApprovedListResultresponse_code"
        },
        "message": {
          "type": "string"
        }
      }
    },
    "protocolTransactionApprovedListResultresponse_code": {
      "type": "string",
      "enum": [
        "SUCCESS",
        "SIGNATURE_FORMAT_ERROR",
        "COMPUTE_ADDRESS_ERROR",
        "OTHER_ERROR"
      ],
      "default": "SUCCESS"
    },
    "protocolTransactionBalanceTrace": {
      "type": "object",
      "properties": {
        "transactionIdentifier": {
          "type": "string",
          "format": "byte"
        },
        "operation": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TransactionBalanceTraceOperation"
          }
        },
        "type": {
          "type": "string"
        },
        "status": {
          "type": "string"
        }
      }
    },
    "protocolTransactionExtention": {
      "type": "object",
      "properties": {
        "transaction": {
          "$ref": "#/definitions/protocolTransaction"
        },
        "txid": {
          "type": "string",
          "format": "byte"
        },
        "constantResult": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          }
        },
        "result": {
          "$ref": "#/definitions/protocolReturn"
        },
        "energyUsed": {
          "type": "string",
          "format": "int64"
        },
        "logs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TransactionInfoLog"
          }
        },
        "internalTransactions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolInternalTransaction"
          }
        },
        "energyPenalty": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolTransactionIdList": {
      "type": "object",
      "properties": {
        "txId": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "protocolTransactionInfo": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "byte"
        },
        "fee": {
          "type": "string",
          "format": "int64"
        },
        "blockNumber": {
          "type": "string",
          "format": "int64"
        },
        "blockTimeStamp": {
          "type": "string",
          "format": "int64"
        },
        "contractResult": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          }
        },
        "contractAddress": {
          "type": "string",
          "format": "byte"
        },
        "receipt": {
          "$ref": "#/definitions/protocolResourceReceipt"
        },
        "log": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TransactionInfoLog"
          }
        },
        "result": {
          "$ref": "#/definitions/protocolTransactionInfocode"
        },
        "resMessage": {
          "type": "string",
          "format": "byte"
        },
        "assetIssueID": {
          "type": "string"
        },
        "withdrawAmount": {
          "type": "string",
          "format": "int64"
        },
        "unfreezeAmount": {
          "type": "string",
          "format": "int64"
        },
        "internalTransactions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolInternalTransaction"
          }
        },
        "exchangeReceivedAmount": {
          "type": "string",
          "format": "int64"
        },
        "exchangeInjectAnotherAmount": {
          "type": "string",
          "format": "int64"
        },
        "exchangeWithdrawAnotherAmount": {
          "type": "string",
          "format": "int64"
        },
        "exchangeId": {
          "type": "string",
          "format": "int64"
        },
        "shieldedTransactionFee": {
          "type": "string",
          "format": "int64"
        },
        "orderId": {
          "type": "string",
          "format": "byte"
        },
        "orderDetails": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolMarketOrderDetail"
          }
        },
        "packingFee": {
          "type": "string",
          "format": "int64"
        },
        "withdrawExpireAmount": {
          "type": "string",
          "format": "int64"
        },
        "cancelUnfreezeV2Amount": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          }
        }
      }
    },
    "protocolTransactionInfoList": {
      "type": "object",
      "properties": {
        "transactionInfo": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolTransactionInfo"
          }
        }
      }
    },
    "protocolTransactionInfocode": {
      "type": "string",
      "enum": [
        "SUCESS",
        "FAILED"
      ],
      "default": "SUCESS"
    },
    "protocolTransactionList": {
      "type": "object",
      "properties": {
        "transaction": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolTransaction"
          }
        }
      }
    },
    "protocolTransactionListExtention": {
      "type": "object",
      "properties": {
        "transaction": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolTransactionExtention"
          }
        }
      }
    },
    "protocolTransactionResult": {
      "type": "object",
      "properties": {
        "fee": {
          "type": "string",
          "format": "int64"
        },
        "ret": {
          "$ref": "#/definitions/TransactionResultcode"
        },
        "contractRet": {
          "$ref": "#/definitions/ResultcontractResult"
        },
        "assetIssueID": {
          "type": "string"
        },
        "withdrawAmount": {
          "type": "string",
          "format": "int64"
        },
        "unfreezeAmount": {
          "type": "string",
          "format": "int64"
        },
        "exchangeReceivedAmount": {
          "type": "string",
          "format": "int64"
        },
        "exchangeInjectAnotherAmount": {
          "type": "string",
          "format": "int64"
        },
        "exchangeWithdrawAnotherAmount": {
          "type": "string",
          "format": "int64"
        },
        "exchangeId": {
          "type": "string",
          "format": "int64"
        },
        "shieldedTransactionFee": {
          "type": "string",
          "format": "int64"
        },
        "orderId": {
          "type": "string",
          "format": "byte"
        },
        "orderDetails": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolMarketOrderDetail"
          }
        },
        "withdrawExpireAmount": {
          "type": "string",
          "format": "int64"
        },
        "cancelUnfreezeV2Amount": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          }
        }
      }
    },
    "protocolTransactionSignWeight": {
      "type": "object",
      "properties": {
        "permission": {
          "$ref": "#/definitions/protocolPermission"
        },
        "approvedList": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          }
        },
        "currentWeight": {
          "type": "string",
          "format": "int64"
        },
        "result": {
          "$ref": "#/definitions/protocolTransactionSignWeightResult"
        },
        "transaction": {
          "$ref": "#/definitions/protocolTransactionExtention"
        }
      }
    },
    "protocolTransactionSignWeightResult": {
      "type": "object",
      "properties": {
        "code": {
          "$ref": "#/definitions/protocolTransactionSignWeightResultresponse_code"
        },
        "message": {
          "type": "string"
        }
      }
    },
    "protocolTransactionSignWeightResultresponse_code": {
      "type": "string",
      "enum": [
        "ENOUGH_PERMISSION",
        "NOT_ENOUGH_PERMISSION",
        "SIGNATURE_FORMAT_ERROR",
        "COMPUTE_ADDRESS_ERROR",
        "PERMISSION_ERROR",
        "OTHER_ERROR"
      ],
      "default": "ENOUGH_PERMISSION"
    },
    "protocolTransactionraw": {
      "type": "object",
      "properties": {
        "refBlockBytes": {
          "type": "string",
          "format": "byte"
        },
        "refBlockNum": {
          "type": "string",
          "format": "int64"
        },
        "refBlockHash": {
          "type": "string",
          "format": "byte"
        },
        "expiration": {
          "type": "string",
          "format": "int64"
        },
        "auths": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolauthority"
          }
        },
        "data": {
          "type": "string",
          "format": "byte",
          "title": "data not used"
        },
        "contract": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TransactionContract"
          },
          "title": "only support size = 1,  repeated list here for extension"
        },
        "scripts": {
          "type": "string",
          "format": "byte",
          "title": "scripts not used"
        },
        "timestamp": {
          "type": "string",
          "format": "int64"
        },
        "feeLimit": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolTransferAssetContract": {
      "type": "object",
      "properties": {
        "assetName": {
          "type": "string",
          "format": "byte"
        },
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        },
        "toAddress": {
          "type": "string",
          "format": "byte"
        },
        "amount": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolTransferContract": {
      "type": "object",
      "properties": {
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        },
        "toAddress": {
          "type": "string",
          "format": "byte"
        },
        "amount": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolUnfreezeAssetContract": {
      "type": "object",
      "properties": {
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolUnfreezeBalanceContract": {
      "type": "object",
      "properties": {
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        },
        "resource": {
          "$ref": "#/definitions/protocolResourceCode"
        },
        "receiverAddress": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolUpdateAssetContract": {
      "type": "object",
      "properties": {
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        },
        "description": {
          "type": "string",
          "format": "byte"
        },
        "url": {
          "type": "string",
          "format": "byte"
        },
        "newLimit": {
          "type": "string",
          "format": "int64"
        },
        "newPublicLimit": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolVote": {
      "type": "object",
      "properties": {
        "voteAddress": {
          "type": "string",
          "format": "byte",
          "title": "the super rep address"
        },
        "voteCount": {
          "type": "string",
          "format": "int64",
          "description": "the vote num to this super rep."
        }
      },
      "title": "vote message"
    },
    "protocolVoteWitnessContract": {
      "type": "object",
      "properties": {
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        },
        "votes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolVoteWitnessContractVote"
          }
        },
        "support": {
          "type": "boolean"
        }
      }
    },
    "protocolVoteWitnessContractVote": {
      "type": "object",
      "properties": {
        "voteAddress": {
          "type": "string",
          "format": "byte"
        },
        "voteCount": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "protocolWithdrawBalanceContract": {
      "type": "object",
      "properties": {
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolWitness": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "format": "byte"
        },
        "voteCount": {
          "type": "string",
          "format": "int64"
        },
        "pubKey": {
          "type": "string",
          "format": "byte"
        },
        "url": {
          "type": "string"
        },
        "totalProduced": {
          "type": "string",
          "format": "int64"
        },
        "totalMissed": {
          "type": "string",
          "format": "int64"
        },
        "latestBlockNum": {
          "type": "string",
          "format": "int64"
        },
        "latestSlotNum": {
          "type": "string",
          "format": "int64"
        },
        "isJobs": {
          "type": "boolean"
        }
      },
      "title": "Witness"
    },
    "protocolWitnessCreateContract": {
      "type": "object",
      "properties": {
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        },
        "url": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolWitnessList": {
      "type": "object",
      "properties": {
        "witnesses": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protocolWitness"
          }
        }
      }
    },
    "protocolWitnessUpdateContract": {
      "type": "object",
      "properties": {
        "ownerAddress": {
          "type": "string",
          "format": "byte"
        },
        "updateUrl": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "protocolauthority": {
      "type": "object",
      "properties": {
        "account": {
          "$ref": "#/definitions/protocolAccountId"
        },
        "permissionName": {
          "type": "string",
          "format": "byte"
        }
      }
    }
  }
}

`)
